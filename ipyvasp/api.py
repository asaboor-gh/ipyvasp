# AUTOGENERATED! DO NOT EDIT! File to edit: MainAPI.ipynb (unless otherwise specified).

__all__ = ['download_structure', '__all__', 'parse_text', 'POSCAR', 'LOCPOT', 'CHG', 'ELFCAR', 'PARCHG', 'OUTCAR',
           'get_axes', 'Bands', 'DOS']

# Cell
import os
from itertools import islice
from contextlib import suppress
import numpy as np
import plotly.graph_objects as go
try:
    from ipyvasp import parser as vp
    from ipyvasp import splots as sp
    from ipyvasp import iplots as ip
    from ipyvasp import sio as sio
    from ipyvasp import widgets as wdg
    from ipyvasp import utils as gu
    from ipyvasp import serializer
    from ipyvasp import surfaces as srf

except:
    import ipyvasp.parser as vp
    import ipyvasp.splots as sp
    import ipyvasp.iplots as ip
    import ipyvasp.sio as sio
    import ipyvasp.widgets as wdg
    import ipyvasp.utils as gu
    import ipyvasp.serializer as serializer
    import ipyvasp.surfaces as srf

def _sub_doc(from_func,skip_param = None, replace = {}):
    """Assing __doc__ from other function. Replace words in docs where need."""
    def wrapper(func):
        docs = from_func.__doc__.splitlines()
        if isinstance(skip_param, (list, tuple)):
            for param in skip_param:
                docs = [line for line in docs if param not in line]
        elif isinstance(skip_param, str):
            docs = [line for line in docs if skip_param not in line]
        docs = '\n'.join(docs)
        for k,v in replace.items():
            docs = docs.replace(k,v)
        func.__doc__ = docs
        return func
    return wrapper

# Cell
def download_structure(formula, mp_id=None, max_sites=None,min_sites=None, api_key=None,save_key = False):
    """Download structure data from Materials project website.
    Args:
        - formula: chemical formula of the material.
        - mp_id: Materials project id of material.
        - max_sites: maximum number of sites in structure to download.
        - min_sites: minimum number of sites in structure to download.
    > max_sites and min_sites are used to filter the number of sites in structure, or use mp_id to download a specific structure.
    - **One Time API Key**
        - api_key: API key from Materials project websit, if you use save_key=True, never required again.
        - save_key: Save API key to file. You can save any time of key or device changed.
    - **Return**
        List of Structure data containing attribute/method `cif`/`export_poscar, write_cif` etc.
    """
    mp = sio.InvokeMaterialsProject(api_key= api_key)
    output = mp.request(formula=formula,mp_id=mp_id,max_sites=max_sites,min_sites=min_sites) # make a request
    if save_key and isinstance(api_key,str):
        mp.save_api_key(api_key)
    if mp.success:
        return output
    else:
        raise ConnectionError('Connection was not sccessful. Try again!')

# Cell
# Direct function exports from modules
_memebers = (
    gu.set_dir,
    gu.get_child_items,
    gu.transform_color,
    gu.interpolate_data,
    sio.get_kpath,
    sio.str2kpath,
    sio.fancy_quiver3d,
    sio.rotation,
    sio.to_basis,
    sio.to_R3,
    sio.periodic_table,
    wdg.generate_summary,
    vp.minify_vasprun,
    vp.xml2dict,
    ip.iplot2html,
    sp.plt2html,
    sp.plt2text,
    sp.show,
    sp.savefig,
    sp.append_axes,
    sp.join_axes,
    sp.add_colorbar,
    sp.color_cube,
    sp.color_wheel,
    sp.add_legend,
    sp.add_text,
    wdg.VasprunApp,
    wdg.KPathApp,
    srf.SpinDataFrame,
)

# Subset of functions from modules in __all__ to make exportable as *
__all__ = [*[_m.__name__ for _m in _memebers],*[a for a in __all__ if a != '__all__']]
for _m in _memebers:
    locals()[_m.__name__] = _m # Assign to local namespace that can be exported, classes only have __name__, not name

# Cell
@_sub_doc(vp.gen2numpy,skip_param= 'gen :', replace= {'shape :':'path : Path to file containing data.\nshape :'})
def parse_text(path, shape, slices, raw:bool = False, dtype = float, delimiter = '\s+', include:str = None,exclude:str = '#',fix_format:bool = True):
    kwargs = {k:v for k,v in locals().items() if k not in ['path']}
    
    if not os.path.isfile(path):
        raise FileNotFoundError(f"File {path!r} does not exists")

    with open(path, 'r', encoding='utf-8') as f:
        gen = islice(f, 0, None)
        data = vp.gen2numpy(gen, **kwargs) # should be under open file context
    return data

# Cell
from contextlib import redirect_stdout
from io import StringIO
from pandas.io.clipboard import clipboard_get, clipboard_set

class POSCAR:
    _cb_instance = {} # Loads last clipboard data if not changed
    _mp_instance = {} # Loads last mp data if not changed
    
    def __init__(self,path = None,content = None,data = None):
        """
        POSACR class to contain data and related methods, data is PoscarData, json/tuple file/string.
        Do not use `data` yourself, it's for operations on poscar.
        
        Parameters
        ----------
        path : path to file
        content : string of POSCAR content
        data : PoscarData object. This assumes positions are in fractional coordinates.

        Prefrence order: data > content > path
        """
        self._path = path
        self._content = content
        self._sd = None # Selective dynamics Array will be stored here if applied.

        if data:
            self._data = serializer.PoscarData.validated(data)
        else:
            self._data = sio.export_poscar(path=path,content = content)
        # These after data to work with data
        self._primitive = False
        self._bz = self.get_bz(primitive = False) # Get defualt regular BZ from sio
        self._cell = self.get_cell() # Get defualt cell
        self._plane = None # Get defualt plane, changed with splot_bz
        self._ax = None # Get defualt axis, changed with splot_bz

    def __repr__(self):
        atoms = ', '.join([f'{k}={len(v)}' for k,v in self._data.types.items()])
        lat = ', '.join([f'{k}={v}' for k,v in zip('abcαβγ',(*self._data.norms.round(3), *self._data.angles.round(3)))])
        return f"{self.__class__.__name__}({atoms}, {lat})"

    def __str__(self):
        return self.content

    @classmethod
    def from_file(cls,path):
        "Load data from POSCAR file"
        return cls(path = path)
    

    @classmethod
    def from_string(cls,content):
        "content should be a valid POSCAR string"
        try:
            return cls(content = content)
        except:
            raise ValueError(f"Invalid POSCAR string!!!!!\n{content}")

    @classmethod
    def from_materials_project(cls,formula, mp_id, api_key = None, save_key = False):
        "Downloads POSCAR from materials project. `mp_id` should be string associated with a material on their website. `api_key` is optional if not saved."
        if cls._mp_instance and cls._mp_instance['kwargs'] == {'formula':formula,'mp_id':mp_id}:
            if api_key and save_key: # If user wants to save key even if data is loaded from cache
                sio._save_mp_API(api_key)
            
            return cls._mp_instance['instance']
        
        instance = cls(data = download_structure(formula=formula,mp_id=mp_id,api_key=api_key,save_key=save_key)[0].export_poscar())
        cls._mp_instance = {'instance':instance,'kwargs':{'formula':formula,'mp_id':mp_id}}
        return instance

    @classmethod
    def from_clipborad(cls):
        "Read POSCAR from clipboard (based on clipboard reader impelemented by pandas library) It picks the latest from clipboard."
        try:
            instance = cls.from_string(content = clipboard_get()) # read from clipboard while allowing error for bad data
            if isinstance(instance,cls): # if valid POSCAR string
                cls._cb_instance = {'instance':instance} # cache instance
                return instance
        except:
            if cls._cb_instance:
                print("Loading from previously cached clipboard data, as current data is not valid POSCAR string.")
                return cls._cb_instance['instance']
            else:
                raise ValueError("Clipboard does not contain valid POSCAR string and no previous data is cached.")

    def to_clipboard(self):
        "Writes POSCAR to clipboard (as implemented by pandas library) for copy in other programs such as vim."
        clipboard_set(self.content) # write to clipboard

    @property
    def data(self):
        "Data object in POSCAR."
        return self._data

    def copy(self):
        "Copy POSCAR object. It avoids accidental changes to numpy arrays in original object."
        return self.__class__(data = self._data.copy())

    @property
    def content(self):
        "POSCAR content."
        with redirect_stdout(StringIO()) as f:
            self.write(outfile = None) # print to stdout
            return f.getvalue()

    @property
    def bz(self):
        return self._bz

    @property
    def sd(self):
        return self._sd

    @property
    def cell(self):
        return self._cell

    @_sub_doc(sio.get_bz,'- path_pos')
    def get_bz(self, loop=True, primitive=False):
        self._bz = sio.get_bz(path_pos = self._data.basis, loop=loop, primitive=primitive)
        self._primitive = primitive
        return self._bz

    def set_bz(self,primitive=False,loop=True):
        """Set BZ in primitive or regular shape. returns None, just set self.bz"""
        self.get_bz(primitive=primitive,loop=loop)

    def get_cell(self, loop=True):
        "See docs of `get_bz`, same except space is inverted and no factor of 2pi."
        self._cell = serializer.CellData(sio.get_bz(path_pos=self._data.rec_basis,loop=loop, primitive=True).to_dict()) # cell must be primitive
        return self._cell

    @_sub_doc(sio.splot_bz,'- bz_data')
    def splot_bz(self, ax=None, plane=None, color='blue', fill=True, vectors=True, v3=False, vname='b', colormap='plasma', light_from=(1, 1, 1), alpha=0.4):
        self._plane = plane # Set plane for splot_kpath
        new_ax = sio.splot_bz(bz_data = self._bz, ax=ax, plane=plane, color=color, fill=fill, vectors=vectors, v3=v3, vname=vname, colormap=colormap, light_from=light_from, alpha=alpha)
        self._ax = new_ax # Set ax for splot_kpath
        return new_ax

    def splot_kpath(self,orderby = (1,1,1), knn_inds = None, labels = None, color='k', line_width = 0.8,marker_size = 10,marker_style = '.',**labels_kwargs):
        """Plot k-path over existing BZ.
        Args:
            - orderby : point relative to which k-points are ordered in fractional coordinates. e.g. (1,1,1) will order k-points by distance from (1,1,1) in fractional coordinates.
            - knn_inds: list of indices of k nearest points e.g. [2,3,1] will trace path linking as 2-3-1.
                0 is Gamma point and 1 is the selected vertex itself. Points are taken internally from BZ, you can see from `self.bz.specials`.
            - labels: list of labels for each k-point in same order as `knn_inds`.
            - color, line_width, marker_size, marker_style are passed to `plt.plot`.

        labels_kwargs are passed to `plt.text`.

        > Tip: You can use this function multiple times to plot multiple/broken paths over same BZ.
        """
        if not self._bz or not self._ax:
            raise ValueError("BZ not found, use `splot_bz` first")

        _specials = self._bz.get_special_points(orderby = orderby)
        nearest = knn_inds

        ijk = [0,1,2]
        _mapping = {'xy':[0,1],'xz':[0,2],'yz':[1,2],'zx':[2,0],'zy':[2,1],'yx':[1,0]}
        if isinstance(self._plane, str) and self._plane in _mapping:
            ijk = _mapping[self._plane]

        inds =  nearest if nearest else range(len(_specials.kpoints)//2) # if not given, take half of points in positive side 
        if not labels:
            labels = ["[{0:6.3f}, {1:6.3f}, {2:6.3f}]".format(*_specials.kpoints[i]) for i in inds]
            if nearest:
                labels = [f"{n}: {_lab}" for n, _lab in zip(nearest, labels)]

        coords = _specials.coords[inds][:,ijk]
        self._ax.plot(*coords.T,color = color,linewidth=line_width,marker=marker_style,markersize=marker_size)

        for c,text in zip(coords, labels):
            self._ax.text(*c,text,**labels_kwargs)
        return self._ax


    def splot_cell(self, ax=None, plane=None, color='blue', fill=True, vectors=True, v3=False, vname='a', colormap='plasma', light_from=(1, 1, 1), alpha=0.4):
        "See docs of `splot_bz`, everything is same except space is inverted."
        return sio.splot_bz(bz_data = self._cell, ax=ax, plane=plane, color=color, fill=fill, vectors=vectors, v3=v3, vname=vname, colormap=colormap, light_from=light_from, alpha=alpha)

    @_sub_doc(sio.iplot_bz,'- bz_data')
    def iplot_bz(self, fill=True, color='rgba(168,204,216,0.4)', background='rgb(255,255,255)', vname='b', special_kpoints = True, alpha=0.4, ortho3d=True, fig=None):
        return sio.iplot_bz(bz_data = self._bz, fill=fill, color=color, background=background, vname=vname, special_kpoints=special_kpoints, alpha=alpha, ortho3d=ortho3d, fig=fig)

    def iplot_cell(self, fill=True, color='rgba(168,204,216,0.4)', background='rgb(255,255,255)', vname='a', alpha=0.4, ortho3d=True, fig=None):
        "See docs of `iplot_bz`, everything is same except space is iverted."
        return sio.iplot_bz(bz_data = self._cell, fill=fill, color=color, background=background, vname=vname, alpha=alpha, ortho3d=ortho3d, fig=fig)

    @_sub_doc(sio.splot_lat,'- poscar_data')
    def splot_lat(self, plane = None, sizes=50, colors = None, colormap=None, bond_length=None, tol=1e-2, bond_tol = 1e-3, eqv_sites=True, translate=None, line_width=1,
                  edge_color=(1, 0.5, 0, 0.4), vectors=True, v3=False, light_from=(1, 1, 1), fill=False, alpha=0.4, ax=None, alpha_points = 0.7):
        return sio.splot_lat(self._data, sizes=sizes, colors=colors, colormap=colormap, bond_length=bond_length, tol=tol, bond_tol = bond_tol, eqv_sites=eqv_sites,
                             translate=translate, line_width=line_width, edge_color=edge_color, vectors=vectors, v3=v3, plane=plane, light_from=light_from, fill=fill,
                             alpha=alpha, alpha_points= alpha_points, ax=ax)
    
    @_sub_doc(sio.iplot_lat,'- poscar_data')
    def iplot_lat(self, sizes=10, colors = None, bond_length=None, tol=1e-2, bond_tol = 1e-3, eqv_sites=True, translate=None, line_width=4, edge_color='black',
                  fill=False, alpha=0.4, ortho3d=True, fig=None):
        return sio.iplot_lat(self._data, sizes=sizes, colors=colors, bond_length=bond_length, tol=tol, bond_tol=bond_tol, eqv_sites=eqv_sites, translate=translate,
                             line_width=line_width, edge_color=edge_color,fill=fill, alpha=alpha, ortho3d=ortho3d, fig=fig)

    def write(self, outfile=None, overwrite=False):
        "Write POSCAR data to file."
        return sio.write_poscar(self._data, outfile=outfile, selective_dynamics= self._sd, overwrite=overwrite)

    @_sub_doc(sio.join_poscars,'- poscar1',replace={'poscar2':'other'})
    def join(self,other, direction='c', tol=0.01, system = None):
        return self.__class__(data = sio.join_poscars(poscar1=self._data, poscar2=other.data, direction=direction, tol=tol,system = system))

    @_sub_doc(sio.scale_poscar,'- poscar_data')
    def scale(self, scale=(1, 1, 1), tol=0.01):
        return self.__class__(data = sio.scale_poscar(self._data, scale=scale, tol=tol))

    @_sub_doc(sio.rotate_poscar,'- poscar_data')
    def rotate(self,angle_deg,axis_vec):
        return self.__class__(data = sio.rotate_poscar(self._data, angle_deg = angle_deg, axis_vec=axis_vec))

    @_sub_doc(sio.fix_sites,'- poscar_data')
    def fix_sites(self, tol=0.01, eqv_sites=False, translate=None):
        return self.__class__(data = sio.fix_sites(self._data, tol=tol, eqv_sites=eqv_sites, translate=translate))

    @_sub_doc(sio.translate_poscar,'- poscar_data')
    def translate(self, offset):
        return self.__class__(data = sio.translate_poscar(self._data, offset=offset))

    @_sub_doc(sio.repeat_poscar,'- poscar_data')
    def repeat(self, n, direction):
        return self.__class__(data = sio.repeat_poscar(self._data, n=n, direction=direction))

    @_sub_doc(sio.mirror_poscar,'- poscar_data')
    def mirror(self, direction):
        return self.__class__(data = sio.mirror_poscar(self._data, direction=direction))

    @_sub_doc(sio.get_transform_matrix,'- poscar_data')
    def get_transform_matrix(self, target_basis):
        return sio.get_transform_matrix(self._data, target_basis)

    @_sub_doc(sio.transform_poscar,'- poscar_data')
    def transform(self, transform_matrix, repeat_given = [2,2,2],tol = 1e-2):
        return self.__class__(data = sio.transform_poscar(self._data, transform_matrix=transform_matrix, repeat_given=repeat_given, tol=tol))

    @_sub_doc(sio.transpose_poscar,'- poscar_data')
    def transpose(self, axes = [1,0,2]):
        return self.__class__(data = sio.transpose_poscar(self._data, axes=axes))

    @_sub_doc(sio.add_vaccum,'- poscar_data')
    def add_vaccum(self, thickness, direction, left = False):
        return self.__class__(data = sio.add_vaccum(self._data, thickness=thickness, direction=direction, left=left))

    @_sub_doc(sio.add_atoms,'- poscar_data')
    def add_atoms(self,name, positions):
        return self.__class__(data = sio.add_atoms(self._data, name=name, positions=positions))

    @_sub_doc(sio.convert_poscar,'- poscar_data')
    def convert(self, atoms_mapping, basis_factor):
        return self.__class__(data = sio.convert_poscar(self._data, atoms_mapping=atoms_mapping, basis_factor=basis_factor))

    def add_selective_dynamics(self, a = None, b = None, c = None, show_plot = True):
        """Returns selective dynamics included POSCAR if input is given. By default, if a direction is not given, it turns ON with others.
        Args:
            - a, b, c: Arrays of shape (N,2) that contain ranges in fractional coordinates to turn selective dynamics on.
            - show_plot: Plots the selective dynamics included sites in fractional orthogonal space to have an idea quickly.

        - **Usage**
            - `add_selective_dynamics(a = [(0,0.1),(0.9,1)])` will turn selective dynamics on for the first and last 10% of the unit cell in a-direction as T T T.
            - `add_selective_dynamics(a = [(0,0.1),(0.9,1)], b = [(0,0.1),(0.9,1)])` will turn selective dynamics on for the first and last 10% of the unit cell in ab-plane in form of T T T, F T T and T F T whichever applies.

        > Returns POSCAR with selective dynamics included. You can write it to file or send to clipboard, but any other transformation will result in loss of selective dynamics information.
        """
        if (a is None) and (b is None) and (c is None):
            return print ('No selective dynamics added. Please provide any of a, b, c to fix sites.')

        sd_poscar = self.__class__(data = self._data) # Create new, don't change original
        sd_poscar._sd = sio.get_selective_dynamics(sd_poscar.data, a = a, b = b, c = c)

        if show_plot:
            import matplotlib.pyplot as plt
            ax1,ax2,ax3 = sp.get_axes((8,3),ncols=3)
            _sel = [i for i,_s in enumerate(sd_poscar._sd) if 'T' in _s]
            _sel_text = [_a.split() for _a in sd_poscar._sd[_sel]]
            _xy = [_sel[i] for i, _s in enumerate(_sel_text) if (_s[0] == 'T' and _s[1] == 'T')]
            _yz = [_sel[i] for i, _s in enumerate(_sel_text) if (_s[1] == 'T' and _s[2] == 'T')]
            _zx = [_sel[i] for i, _s in enumerate(_sel_text) if (_s[2] == 'T' and _s[0] == 'T')]

            ax1.scatter(*sd_poscar.data.positions[_xy][:,[0,1]].T,marker='.')
            ax2.scatter(*sd_poscar.data.positions[_xy][:,[1,2]].T,marker='.')
            ax3.scatter(*sd_poscar.data.positions[_xy][:,[2,0]].T,marker='.')

            for ax, lx,ly in zip([ax1,ax2,ax3],['a','b','c'],['b','c','a']):
                ax.set_xlabel(lx)
                ax.set_ylabel(ly)
                ax.set_xlim([-0.01,1.01]) # For view in place
                ax.set_ylim([-0.01,1.01])

            ax1.get_figure().suptitle('Selective dynamics included sites in fractional coordinates')
            plt.tight_layout()
            plt.show() # From scripts it should pop up automatically

        return sd_poscar

    @_sub_doc(sio.get_kmesh,'- poscar_data')
    def get_kmesh(self, *args, shift = 0, weight=None, cartesian = False, ibzkpt=None, outfile=None,endpoint = True):
        return sio.get_kmesh(self.data, *args, shift = shift, weight = weight, cartesian = cartesian,ibzkpt= ibzkpt, outfile=outfile, endpoint = endpoint)

    @_sub_doc(sio.get_kpath,'- rec_basis')
    def get_kpath(self,*patches, n = 5,weight= None ,ibzkpt = None,outfile=None):
        return sio.get_kpath(*patches, n = n,weight= weight ,ibzkpt = weight,outfile=outfile, rec_basis = self.data.rec_basis)

    @_sub_doc(sio.str2kpath,'- rec_basis')
    def str2kpath(self, kpath_str,n = 5, weight = None, ibzkpt = None, outfile = None):
        return sio.str2kpath(kpath_str, n = n, weight = weight, ibzkpt = ibzkpt, outfile = outfile, rec_basis = self.data.rec_basis)


    def bring_in_cell(self,points):
        """Brings atoms's positions inside Cell and returns their R3 coordinates.
        """
        # Cartesain POSCAR is also loaded as relative to basis in memeory, so both same
        return self.to_R3(points, reciprocal = False)

    @_sub_doc(sio.kpoints2bz,'- bz_data')
    def bring_in_bz(self,kpoints, sys_info = None, shift = 0):
        """Brings kpoints inside already set BZ, (primitive or regular).
        If basis is not None, returns kpoints relative to those basis.
        If kpoints are cartesian, sys_info will take care of scaling them.
        `shift` is a number or a list of three numbers that will be added to kpoints before any other operation.
        """
        if not self._bz:
            raise RuntimeError('No BZ found. Please run `get_bz()` first.')
        return sio.kpoints2bz(self._bz, kpoints= kpoints,primitive = self._primitive, sys_info = sys_info, shift = shift)
    
    def to_R3(self, points, reciprocal = False):
        "Converts points to R3 coordinates. If reciprocal is True, converts to R3 in reciprocal basis."
        points = np.array(points) # In case list of lists
        if reciprocal:
            return sio.to_R3(self.data.rec_basis, points)
        return sio.to_R3(self.data.basis, points)
        

# Cell
class LOCPOT:
    """
    - Returns Data from LOCPOT and similar structure files. Loads only single set out of 2/4 magnetization data to avoid performance/memory cost while can load electrostatic and one set of magnetization together.
    Args:
        - path: path/to/LOCPOT. LOCPOT is auto picked in CWD.
        - data_set: 0 for electrostatic data, 1 for magnetization data if ISPIN = 2. If non-colinear calculations, 1,2,3 will pick Mx,My,Mz data sets respectively. Only one data set is loaded, so you should know what you are loading.
    - **Exceptions**
        - Would raise index error if magnetization density set is not present in LOCPOT/CHG in case `m` is not False.

    **Note:** To avoid memory issues while loading multiple LOCPOT files, use this class as a context manager which cleans up the memory after use.
    ```python
    with LOCPOT('path/to/LOCPOT') as tmp:
        tmp.splot()
    # The object tmp is destroyed here and memory is freed.
    ```
    """
    def __init__(self,path = None,data_set = 0):
        self._path = path # Must be
        self._data = vp.export_locpot(path = path, data_set = data_set)

        self.rolling_mean = gu.rolling_mean # For quick access to rolling mean function.

    def __enter__(self):
        import weakref
        return weakref.proxy(self)

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    @property
    def poscar(self):
        "POSCAR class object"
        return POSCAR(data = self._data.poscar)

    @property
    def data(self):
        return self._data

    @_sub_doc(sp.plot_potential,'- values')
    def splot(self,operation='mean_c',ax=None,period=None, period_right=None,
                 lr_pos=(0.25,0.75),interface=None, smoothness=2,
                 labels=(r'$V(z)$',r'$\langle V \rangle _{roll}(z)$',r'$\langle V \rangle $'),
                 colors = ((0,0.2,0.7),'b','r'),annotate=True):
        return sp.plot_potential(basis=self._data.poscar.basis,values=self._data.values,operation=operation,
                                    ax=ax,period=period,lr_pos=lr_pos,period_right=period_right, smoothness=smoothness,interface=interface,
                                    labels=labels,colors=colors,annotate=annotate)

    def check_period(self, operation: str = 'mean_c',interface = 0.5,lr_pos = (0.25,0.75), smoothness = 2, figsize = (5,3),**kwargs):
        """Check periodicity using ipywidgets interactive plot.
        - operation: What to do, such as 'mean_c' or 'mean_a' etc.
        - interface: Interface in range [0,1] to divide left and right halves.
        - lr_pos: Tuple of (left,right) positions in range [0,1] to get ΔV of right relative to left.
        - smoothness: int. Default is 2. Smoothing parameter for rolling mean. Larger is better.
        - figsize: Tuple of (width,height) of figure. Since each time a figure is created, we can't reuse it, so we need to specify the size.
        kwargs are passed to the plt.Axes.set(kwargs) method to handle the plot styling.
        """
        check = ['mean_a','min_a','max_a','mean_b','min_b','max_b','mean_c','min_c','max_c']
        if operation not in check:
            raise ValueError("operation expects any of {!r}, got {}".format(check,operation))

        opr, _dir = operation.split('_')
        x_ind = 'abc'.index(_dir)
        other_inds = tuple([i for i in [0,1,2] if i != x_ind])
        _func_ = getattr(np,opr)
        X_1 = _func_(self._data.values,axis = other_inds)

        _step = round(1/X_1.size,4)
        _min = round(4*_step,4) # At least 4 steps per period

        import ipywidgets as ipw
        import matplotlib.pyplot as plt

        def checker(period, period_right):
            fig, ax = plt.subplots(1,1,figsize=figsize)
            ax.plot(X_1,label=operation,lw=1)
            X_2 = self.rolling_mean(X_1,period,period_right=period_right,interface=interface, smoothness=smoothness)
            ax.plot(X_2,label='rolling_mean',ls='dashed',lw=1)

            x = [int(X_2.size*p) for p in lr_pos]
            y = X_2[x]
            ax.step(x,y,where = 'mid',marker='.',lw=0.7)
            ax.text(0,y.mean(),f'$V_{{R}} - V_{{L}}$ : {y[1]-y[0]:.6f}',backgroundcolor=[1,1,1,0.5])
            plt.legend(bbox_to_anchor=(0, 1),loc='lower left',ncol=2,frameon=False)
            ax.set(**kwargs)
            return ax

        return ipw.interactive(checker,
                period = ipw.FloatSlider(min=_min,max=0.5,value=0.125,step=_step,readout_format='.4f', continuous_update=False),
                period_right=ipw.FloatSlider(min=_min,max=0.5,value=0.125,step=_step,readout_format='.4f', continuous_update=False),
                )


class CHG(LOCPOT):
    __doc__ = LOCPOT.__doc__.replace('LOCPOT','CHG')
    def __init__(self, path = None,data_set = 0):
        super().__init__(path or 'CHG',data_set = data_set)

class ELFCAR(LOCPOT):
    __doc__ = LOCPOT.__doc__.replace('LOCPOT','ELFCAR')
    def __init__(self, path = None,data_set = 0):
        super().__init__(path or 'ELFCAR',data_set=data_set)


class PARCHG(LOCPOT):
    __doc__ = LOCPOT.__doc__.replace('LOCPOT','PARCHG')
    def __init__(self, path = None,data_set = 0):
        super().__init__(path or 'PARCHG',data_set = data_set)

# Cell
class OUTCAR:
    "Parse some required data from OUTCAR file."
    def __init__(self,path = None):
        self._path = path # Must be
        self._data = vp.export_outcar(path = path)

    @property
    def data(self):
        return self._data

    @property
    def path(self):
        return self._path

# Cell
@_sub_doc(sp.get_axes,'- self',replace={'get_axes':'get_axes'})
def get_axes(figsize=(3.4, 2.6), nrows=1, ncols=1, widths=[], heights=[], axes_off=[], axes_3d=[], sharex=False, sharey=False, azim=45, elev=15, ortho3d=True, **subplots_adjust_kwargs):
    axes = sp.get_axes(figsize=figsize, nrows=nrows, ncols=ncols, widths=widths, heights=heights, axes_off=axes_off, axes_3d=axes_3d, sharex=sharex, sharey=sharey, azim=azim, elev=elev, ortho3d=ortho3d, **subplots_adjust_kwargs)
    for ax in np.array([axes]).flatten():
        for f in [sp.add_text,sp.add_legend,sp.add_colorbar,sp.color_wheel,sp.break_spines,sp.modify_axes,sp.append_axes, sp.join_axes]:
            if ax.name != '3d':
                setattr(ax,f.__name__,f.__get__(ax,type(ax)))
    return axes
get_axes.__doc__ = get_axes.__doc__ + '''
**There are extra methods added to each axes (only 2D) object.**
- add_text
- add_legend
- add_colorbar
- color_wheel
- break_spines
- modify_axes
- append_axes
- join_axes
'''

def _format_input(atoms_orbs_dict, sys_info):
    """
    Format input atoms, orbs and labels according to select projections in atoms_orbs_dict.
    For example: {'Ga-s':(0,[1]),'Ga-p':(0,[1,2,3]),'Ga-d':(0,[4,5,6,7,8])} #for Ga in GaAs, to pick Ga-1, use [0] instead of 0 at first place
    """
    if not isinstance(atoms_orbs_dict,dict):
        raise TypeError("`atoms_orbs_dict` must be a dictionary, with keys as labels and values from picked projection indices.")
    
    if not hasattr(sys_info,'orbs'): 
        raise ValueError("No orbitals found to pick from given data.")
    
    types = list(sys_info.types.values())
    names = list(sys_info.types.keys())
    max_ind = np.max(types)
    norbs = len(sys_info.orbs)
    
    # Set default values for different situations
    atoms, orbs, labels = [], [], []

    for i, (k, v) in enumerate(atoms_orbs_dict.items()):
        if len(v) != 2:
            raise ValueError(f"{k!r}: {v} expects 2 items (atoms, orbs), got {len(v)}.")
        
        if not isinstance(k,str):
            raise TypeError(f"{k!r} is not a string. Use string as key for labels.")
        
        labels.append(k)
        
        A, B = v # A is atom, B is orbs only two cases: (1) int (2) list of int
        
        if not isinstance(A,(int,np.integer,list,tuple, range)):
            raise TypeError(f"{A!r} is not an integer or list/tuple/range of integers.")
        
        if not isinstance(B,(int,np.integer,list,tuple,range)):
            raise TypeError(f"{B!r} is not an integer or list/tuple/range of integers.")
        
        # Fix orbs
        B = [B] if isinstance(B,(int,np.integer)) else B
        
        if np.max(B) >= norbs:
            raise IndexError("index {} is out of bound for {} orbs".format(np.max(B),norbs))
        if np.min(B) < 0:
            raise IndexError("Only positive integers are allowed for selection of orbitals.")
        
        orbs.append(B)
        
        # Fix atoms
        if isinstance(A, (int,np.integer)):
            if A < 0:
                raise IndexError("Only positive integers are allowed for selection of atoms.")
            
            if A < len(types):
                atoms.append(types[A])
                info = f"Given {A} at position {i+1} of sequence => {names[A]!r}: {atoms[i]}. "
                print(gu.color.g(info + f"To just pick one ion, write it as [{A}]."))
            else:
                raise IndexError(f"index {A}  at is out of bound for {len(types)} types of ions. Wrap {A} in [] to pick single ion if that was what you meant.")
        else:
            if np.max(A) > max_ind:
                raise IndexError(f"index {np.max(A)} is out of bound for {max_ind+1} ions")
            
            if np.min(A) < 0:
                raise IndexError("Only positive integers are allowed for selection of atoms.")
            
            atoms.append(A)
    
    uatoms = np.unique([a for aa in atoms for a in aa]) # don't use set, need asceding order
    uorbs = np.unique([o for oo in orbs for o in oo])
    uorbs = tuple(uorbs) if len(uorbs) < norbs else -1 # -1 means all orbitals
    uatoms = tuple(uatoms) if len(uatoms) == (max_ind + 1) else -1 # -1 means all atoms

    return atoms,orbs,labels, uatoms, uorbs

_spin_doc = 'spin : int, 0 by default. Use 0 for spin up and 1 for spin down for spin polarized calculations.'
_proj_doc = "atoms_orbs_dict : dict, str -> [atoms, orbs]. Use dict to select specific projections, e.g. {'Ga-s': (0,[0]), 'Ga1-p': ([0],[1,2,3])} in case of GaAs."

class _BandsDosBase:
    def __init__(self, source):
        if not isinstance(source, vp.DataSource):
            raise TypeError('`source` must be a subclass of `ipyvasp.parser.DataSource`.')
        self._source = source # source is instance of DataSource
        self._data = None # will be updated on demand
    
    @property
    def source(self):
        return self._source
    
    @property
    def data(self):
        "Returns a dictionary of information about the picked data after a plotting function called."
        return self._data

class Bands(_BandsDosBase):
    """
    Class to handle and plot bandstructure data.
    
    Parameters
    ----------
    source : instance of `ipyvasp.DataSource` such as `ipyvasp.Vasprun` or `ipyvasp.Vaspout`. You can define your own class to parse data with same attributes and methods by subclassing `ipyvasp.DataSource`.
    """
    def __init__(self, source):
        super().__init__(source)
        
    def get_kticks(self, rel_path = 'KPOINTS'):
        """
        Reads associated KPOINTS file form a relative path of calculations and returns kticks. If KPOINTS file does not exist or was not created by this module, returns empty dict.
        
        .. note:: 
            kticks become useless when you interploate data in plotting, in that case write kticks manually.
        """
        file = os.path.join(os.path.dirname(self.source.path),rel_path)
        if os.path.isfile(file):
            return sio.read_kticks(file)
        return []
                
    def get_data(self, spin = 0, elim = None, atoms_orbs_dict: dict = None):
        """
        Selects bands and projections to use in plotting functions.
        
        Parameters
        ----------
        spin : int, 0 by default. Use 0 for spin up and 1 for spin down for spin polarized calculations.
        elim : list, tuple of two floats to pick bands in this energy range. If None, picks all bands.
        atoms_orbs_dict : dict, str -> [atoms, orbs]. Use dict to select specific projections, e.g. {'Ga-s': (0,[0]), 'Ga1-p': ([0],[1,2,3])} in case of GaAs.
        
        Returns
        -------
        dict : Selected bands and projections dictionary to be used in bandstructure plotting functions under this class as `data` argument.
        """
        if spin not in [0,1]:
            raise ValueError('spin must be 0 or 1')
        
        atoms, orbs, labels, uatoms, uorbs, blim = None, None, None, None, None, None
        if atoms_orbs_dict:
            atoms, orbs, labels, uatoms, uorbs = _format_input(atoms_orbs_dict, self.source.get_summary())
        
        if self._data and (1 - self._data.spin) == spin: # if they have used other channel before
            print('Using same bands for spin up and spin down. Run again to change and bands range and then apply same on other spin channel.')
            blim = min(self._data.bands), max(self._data.bands)
        
        kpts = self._source.get_kpoints()
        eigens = self._source.get_evals(spin = spin, elim = elim, atoms = uatoms, orbs = uorbs, blim = blim) # others be there
        
        output = {'kpath': kpts.kpath, 'kpoints': kpts.kpoints, 'coords': kpts.coords, **eigens.to_dict()}
        output['kvc'] = tuple(tuple(round(kpts.kpath[i],4) for i in kp) for kp in eigens.kvc) # 4 digits are enough to handle 10,000 kpoints
        
        if hasattr(eigens, 'pros'):
            arrays = []
            for atom,orb in zip(atoms,orbs):
                if uatoms != -1:
                    atom = [i for i, a in enumerate(eigens.atoms) if a in atom] # indices for partial data loaded
                if uorbs != -1:
                    orb = [i for i, o in enumerate(eigens.orbs) if o in orb]
                _pros  = np.take(eigens.pros,atom,axis=2).sum(axis=2) # Sum over atoms leaves 3D array
                _pros = np.take(_pros,orb,axis=2).sum(axis=2) # Sum over orbitals leaves 2D array
                arrays.append(_pros)

            output['pros'] = np.array(arrays)
            output['labels'] = labels
            output.pop('atoms', None) # No more needed
            output.pop('orbs', None)
        
        self._data = serializer.Dict2Data(output) # Assign for later use
        return self._data
    
    def _handle_kwargs(self, kwargs):
        "Returns fixed kwargs and new elim relative to fermi energy for gettig data."
        if kwargs.get('kticks',None):
            kwargs['kticks'] = kwargs['kticks'] or self.get_kticks() # Does not change even after interpolation, prefer user
        
        efermi = kwargs.pop('efermi',None) # remove from kwargs as plots don't need it
        elim = kwargs.get('elim',None)
        new_elim = [e + (efermi or 0) for e in elim] if isinstance(elim,(list, tuple)) else None
        return kwargs, new_elim, efermi
    
    @_sub_doc(sp.splot_bands,['K :','E :'],replace = {'ax :': f"{_spin_doc}\n    ax :"})
    def splot_bands(self, spin = 0, ax = None, elim = None, efermi = None, kticks = None, interp = None, **kwargs):
        plot_kws = {k:v for k,v in locals().items() if k not in ['self','spin','kwargs']} # should be on top to avoid other loacals
        plot_kws, new_elim, fermi = self._handle_kwargs(plot_kws)
        data = self.get_data(spin = spin, elim = new_elim) # picked relative limit
        
        if fermi is None:
            fermi = data['evc'][0]
        
        return sp.splot_bands(data.kpath, data.evals - fermi, **plot_kws, **kwargs)
    
    @_sub_doc(sp.splot_rgb_lines,['K :','E :', 'pros :', 'labels :'], replace = {'ax :': f"{_proj_doc}\n    {_spin_doc}\n    ax :"})
    def splot_rgb_lines(self, atoms_orbs_dict,
        spin       = 0,   
        ax         = None, 
        elim       = None, 
        efermi     = None,
        kticks     = None, 
        interp     = None, 
        maxwidth   = 3,
        colormap   = None,
        colorbar   = True,
        N          = 9,
        shadow     = False):
        plot_kws = {k:v for k,v in locals().items() if k not in ['self','spin', 'atoms_orbs_dict']} # should be on top to avoid other loacals
        plot_kws, new_elim, fermi = self._handle_kwargs(plot_kws)
        data = self.get_data(spin, new_elim, atoms_orbs_dict) # picked relative limit
        
        if fermi is None:
            fermi = data['evc'][0]
            
        return sp.splot_rgb_lines(data.kpath, data.evals - fermi, data.pros, data.labels, **plot_kws)
    
    @_sub_doc(sp.splot_color_lines,['K :','E :', 'pros :', 'labels :'], replace = {'ax :': f"{_proj_doc}\n    {_spin_doc}\n    ax :"})
    def splot_color_lines(self, atoms_orbs_dict,
        spin       = 0, 
        axes       = None, 
        elim       = None, 
        efermi     = None,
        kticks     = None, 
        interp     = None, 
        maxwidth   = 3,
        colormap   = None,
        shadow     = False,
        showlegend = True,
        xyc_label   = [0.2, 0.85, 'black'], # x, y, color only if showlegend = False
        **kwargs
        ):
        plot_kws = {k:v for k,v in locals().items() if k not in ['self','spin', 'atoms_orbs_dict','kwargs']} # should be on top to avoid other loacals
        plot_kws, new_elim, fermi = self._handle_kwargs(plot_kws)
        data = self.get_data(spin, new_elim, atoms_orbs_dict) # picked relative limit
        
        if fermi is None:
            fermi = data['evc'][0]
        
        return sp.splot_color_lines(data.kpath, data.evals - fermi, data.pros, data.labels, **plot_kws, **kwargs)
    
    @_sub_doc(ip.iplot_rgb_lines,['K :','E :', 'pros :', 'labels :','occs :','kpoints :'], replace = {'fig :': f"{_proj_doc}\n    {_spin_doc}\n    fig :"})
    def iplot_rgb_lines(self, atoms_orbs_dict,
        spin       = 0,
        elim       = None,
        efermi     = None,
        kticks     = None, 
        interp     = None, 
        maxwidth   = 10,   
        mode       = 'markers + lines',
        fig        = None,
        title      = None,
        **kwargs              
        ):
        plot_kws = {k:v for k,v in locals().items() if k not in ['self','spin', 'atoms_orbs_dict','kwargs']} # should be on top to avoid other loacals
        plot_kws, new_elim, fermi = self._handle_kwargs(plot_kws)
        data = self.get_data(spin, new_elim, atoms_orbs_dict) # picked relative limit
        
        if fermi is None:
            fermi = data['evc'][0]
         
        return ip.iplot_rgb_lines(data.kpath, data.evals - fermi, data.pros, data.labels, data.occs, data.kpoints, **plot_kws, **kwargs)
     
     
class DOS(_BandsDosBase):
    """
    Class to handle and plot density of states data.
    
    Parameters
    ----------
    source : instance of `ipyvasp.DataSource` such as `ipyvasp.Vasprun` or `ipyvasp.Vaspout`. You can define your own class to parse data with same attributes and methods by subclassing `ipyvasp.DataSource`.
    """
    def __init__(self, source):
        super().__init__(source)
    
    def get_data(self, spin = 0, elim = None, atoms_orbs_dict: dict = None):
        if spin not in [0,1]:
            raise ValueError('spin must be 0 or 1')
        
        atoms, orbs, labels, uatoms, uorbs, gridlim = None, None, None, None, None, None
        if atoms_orbs_dict:
            atoms, orbs, labels, uatoms, uorbs = _format_input(atoms_orbs_dict, self.source.get_summary())
        
        if self._data and (1 - self._data.spin) == spin: # if they have used other channel before
            print('Using same energy limit for spin up and spin down. Run again to change it, then apply same on other spin channel.')
            gridlim = min(self._data.bands), max(self._data.bands)
        
        data = self._source.get_dos(spin = spin, elim = elim, atoms = uatoms, orbs = uorbs, gridlim = gridlim)