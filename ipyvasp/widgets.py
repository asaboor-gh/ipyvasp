# AUTOGENERATED! DO NOT EDIT! File to edit: Widgets.ipynb (unless otherwise specified).

__all__ = ['css_style', 'dark_colors', 'light_colors', 'simple_colors', 'default_colors', 'InputGui',
           'summarize', 'FilesWidget', 'VasprunApp', 'KPathApp']

# Cell
import re, os, textwrap
import json
from time import sleep, time
from pathlib import Path
from collections import Iterable
from functools import lru_cache

# Widgets Imports
from IPython.display import display, Markdown
from IPython import get_ipython #For SLides
import ipywidgets as ipw
from ipywidgets import Layout,Label,Button,Box,HBox,VBox,Dropdown,Text,Checkbox, SelectMultiple
from ipywidgets.embed import embed_minimal_html, dependency_state

# More exports
import numpy as np
import pandas as pd
import plotly.graph_objects as go

# Inside packages import to work both with package and jupyter notebook.
try:
    from ipyvasp import utils as gu
    from ipyvasp import parser as vp
    from ipyvasp import iplots as ip
    from ipyvasp import splots as sp
    from ipyvasp import sio
    from ipyvasp import serializer
except:
    import ipyvasp.utils as gu
    import ipyvasp.parser as vp
    import ipyvasp.iplots as ip
    import ipyvasp.splots as sp
    import ipyvasp.sio as sio
    import ipyvasp.serializer as serializer

# Cell
def css_style(colors_dict,_class = 'main_wrapper'):
    """Return style based on colors_dict available as pp.light_colors, pp.dark_colors etc"""
    return """<style>
    .{_class} h1,h2,h3,h4,h5,h6 {{
        color: {accent} !important;
    }}
    .{_class} .widget-label-basic {{
        background-color: transparent !important;
        color: {main_fg} !important;
    }}
    .{_class} .widget-text input {{
        background-color: {next_bg} !important;
        border-radius:20px !important;
        padding: 0px 10px 0px 10px !important;
        border: 1px solid {next_bg} !important;
        color: {main_fg} !important;
        }}
    .{_class} .widget-text input:focus {{
        border: 1px solid {hover_bg} !important;
        }}
    .{_class} .widget-text input:hover {{
        border: 1px solid {hover_bg} !important;
        }}
    .{_class} .widget-dropdown > select {{
        background-color: {next_bg} !important;
        border:none !important;
        border-bottom: 1px solid {hover_bg} !important;
        box-shadow: inset 0 -20px 10px -20px {hover_bg};
        color: {main_fg} !important;
    }}
    .{_class} .widget-dropdown > select:hover {{
        background-color: {hover_bg} !important;
    }}
    .{_class} .widget-dropdown > select > option {{
        color: {main_fg} !important;
        background-color: {next_bg} !important;
    }}
    .{_class} .widget-dropdown > select > option:focus {{
        background-color: {hover_bg} !important;
    }}
    .{_class} .widget-label {{
        color: {main_fg} !important;
    }}
    .{_class} .widget-html {{
        color: {main_fg} !important;
    }}
    .{_class} .widget-box, .{_class}.widget-box {{
        background-color: {main_bg} !important;
        border-radius:5px !important;
        padding:1px !important;
        border: 1px solid {next_bg} !important;
        box-shadow: 1px 1px 1px 1px {next_bg} !important;
    }}
    .{_class} .borderless, .{_class}.borderless {{
        border: 1px solid transparent !important;
        box-shadow: none !important;
        border-radius: 4px !important;
        margin:4px !important;
    }}
    .{_class} .marginless, .{_class}.marginless {{
        margin: 0px !important;
        border-radius: 0px !important;
    }}
    .{_class} .output, .{_class}.output {{
        color: {main_fg} !important;
        background-color: inherit !important;
    }}
    .{_class} .widget-tab, .{_class}.widget-tab {{
        background-color: {main_bg} !important;
        border: none !important;
        box-shadow: 1px 1px 1px 1px {next_bg} !important;
        padding: 0px 2px 2px 2px !important;
    }}
    .{_class} .widget-tab-contents, .{_class}.widget-tab > .widget-tab-contents {{
        width: 100%;
        box-sizing: border-box;
        margin: 0px !important;
        padding: 0px !important;
        flex-grow: 1;
        overflow: auto;
        border: none !important;
        background-color: {main_bg} !important;
    }}
    .{_class} .widget-tab > .p-TabBar .p-TabBar-tab, .{_class}.widget-tab > .p-TabBar .p-TabBar-tab {{
        background-color:{main_bg} !important;
        border: none !important;
        color: {accent} !important;
        font-weight: bold !important;
        font-size: 16px !important;
        font-family: "Times","serif" !important;
        text-align: center !important;
    }}
    .{_class} table {{
        color: {main_fg} !important;
        }}
    .{_class} tr:nth-child(odd) {{
        background-color: {next_bg} !important;
        }}
    .{_class} tr:nth-child(even) {{
        background-color: {main_bg} !important;
        }}
    .{_class} .widget-button,.widget-toggle-button {{
        color:  {accent} !important;
        min-width: max-content !important;
        background-color: {next_bg};
        border-radius: 5px !important;
    }}
    .{_class} tr:hover {{
        background-color: {hover_bg} !important;
        }}
    </style>
    """.format(**colors_dict,_class= _class)

dark_colors = {
 'main_fg'  : '#ABB2BF',
 'main_bg'  : '#21252B',
 'next_bg'  : '#282C34',
 'hover_bg' : '#414855',
 'accent'   : '#61AFEF'
}

light_colors = {
 'next_bg'  : 'white',
 'hover_bg' : '#abe4ff',
 'accent'   : 'navy',
 'main_bg'  : '#F3F3F3',
 'main_fg'  : 'black'
}
simple_colors = {
 'hover_bg' : 'lightgray',
 'accent'   : 'black',
 'main_bg'  : 'white',
 'main_fg'  : 'black',
 'next_bg'  : 'whitesmoke'
}
default_colors = {  # Adopt Jupyterlab theme
 'main_fg' : 'var(--jp-inverse-layout-color0,black)',
 'main_bg' : 'var(--jp-layout-color0,#F3F3F3)',
 'next_bg' : 'var(--jp-layout-color2,white)',
 'hover_bg': 'var(--jp-border-color1,lightblue)',
 'accent'  : 'var(--jp-brand-color2,navy)'
}

def summarize(files, func, **kwargs):
    """
    Apply given func to each file in files and return a dataframe of the results.
    
    Parameters
    ----------
    files: Iterable, must be an iterable of PathLike objects, a dictionary of {name: PathLike} pairs also works and name appears in the dataframe.
    func: callable with a single arguemnt path.  Must return a dictionary.
    
    kwargs: passed to func itself.
    """
    if not callable(func):
        raise TypeError('Argument `func` must be a function.')
    
    if not isinstance(files, Iterable):
        raise TypeError('Argument `files` must be an iterable of PathLike objects.')
    
    if not isinstance(files, dict):
        files = {str(path): path for path in files} # make a dictionary of paths
        
    
    outputs = []
    for name, path in files.items():
        output = func(path, **kwargs)
        if not isinstance(output,dict):
            raise TypeError('Function must return a dictionary.')
        
        if 'FILE' in output:
            raise KeyError('FILE is a reserved key to store the file name for reference.')
        
        outputs.append({**output, 'FILE': name}) # add the file name to the output at the end
    
    unique_keys = [] # get all unique keys, there would be missing or extra keys, handle all
    for key in [key for out in outputs for key in out.keys()]:
        if key not in unique_keys:
            unique_keys.append(key)
    
    
    return pd.DataFrame({ukey: [out.get(ukey, None) for out in outputs] for ukey in unique_keys})


_progress_svg = '''<svg xmlns="http://www.w3.org/2000/svg" height="5em" viewBox="0 0 50 50">
    <path fill="skyblue" d="M25,5A20.14,20.14,0,0,1,45,22.88a2.51,2.51,0,0,0,2.49,2.26h0A2.52,2.52,0,0,0,50,22.33a25.14,25.14,0,0,0-50,0,2.52,2.52,0,0,0,2.5,2.81h0A2.51,2.51,0,0,0,5,22.88,20.14,20.14,0,0,1,25,5Z">
        <animateTransform attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.2s" repeatCount="indefinite"/>
    </path>
</svg>'''

class FilesWidget(VBox):
    """A widget for selecting files from a directory and its subdirectories.
    
    Parameters
    ----------
    base_path : str, default is '.'. The path to the directory to search.
    glob : str, default is '*'. The glob pattern to match files against. See https://docs.python.org/3/library/glob.html
    exclude : str, default is None. A regex pattern to exclude files from the selection.
    
    Returns
    -------
    A FilesWidget object where you can filter files by typing in the text box, and select files from the dropdown.
    """
    def __init__(self, base_path : str = '.', glob :str = '*', exclude :str = None) -> None:
        for prop in (base_path, glob, exclude):
            if prop and not isinstance(prop, str):
                raise ValueError(f'Expected string, got {type(prop)}')
            
        VBox.__init__(self,_dom_classes = ['FilesWidget']) # This makes it truely a widget
        self._files = [] # Selections stored as Path objects
        self._widgets = {
            'input': Text(value = base_path, description = 'Path:'),
            'glob' : Text(value = glob, description = 'Glob:'),
            'exclude' : Text(value = exclude or '', description = 'Exclude:'),
            'lock' : Checkbox(value = False, description = 'Lock selection'),
            'files' : Dropdown(options = [], description = 'File:'),
        }
        self.children = [self._widgets['input'], self._widgets['glob'], self._widgets['exclude']]
        self._widgets['lock'].observe(self._lock_selection, names = ['value'])
        
        for key, value in self._widgets.items():
            if key not in ['files','lock','title']:
                value.on_submit(self._process)
        
        self._process(None) # Initial processing based on given values
                
    def _lock_selection(self, change):
        for key, value in self._widgets.items():
            if key not in ['files','lock']:
                value.disabled = self._widgets['lock'].value # Don't allow changes even programatically
        
        if self._widgets['lock'].value:
            self._widgets['lock'].description = f'{len(self._files)} files selected'
            self.children = [self._widgets['lock'], self._widgets['files']]
        else:
            self.children = [self._widgets['input'],self._widgets['glob'],self._widgets['exclude']]
        
    def _process(self,change):
        self._widgets['lock'].description = 'Processing...'   
        files = gu.list_files(self._widgets['input'].value, glob = self._widgets['glob'].value, exclude = self._widgets['exclude'].value)
            
        self._widgets['files'].options = [str(p) for p in files] # shows only relative path
        self._files = [path.absolute() for path in files] # Store as full path
        self.children = list(self._widgets.values()) #  show all widgets
        self._widgets['lock'].description = f'{len(self._files)} files found. Lock selection?'
        
    @property
    def files(self):
        "Returns all availble files as Path objects."
        return tuple(self._files)
    
    @property
    def dropdown(self):
        "Returns the dropdown widget to select files."
        return self._widgets['files']
    
    @property
    def selected(self) -> Path:
        "Returns selected item in the dropdown as Path object."
        if self._widgets['files'].value: # if not empty, otherwise it throws error
            return Path(self._widgets['files'].value).absolute() # return full path
        
    def get_sibling(self, name : str) -> Path:
        "Returns sibling of selected item by a given name as Path object. This does not check if the sibling exists."
        if self.selected:
            return self.selected.parent / name
        else:
            raise ValueError('No file selected.')
        
    def interactive(self, func, other_widgets = None, other_controls = None, options = {'manual':False}, max_height = '90vh', **kwargs):
        """
        Interact with a function that takes selected Path as first argument. Returns a widget that saves attributes of the function call such as .f, .args, .kwargs.
        See docs of self.interact for more details on the parameters. kwargs are passed to ipywidgets.interactive to create controls.
        
        .. highlight:: python
        .. code-block:: python
        
            fw = FilesWidget()
            out = fw.interactive(lambda path: print(path.read_text())) # prints contents of selected file on output widget
            out.f # function
            out.args # arguments
            out.kwargs # keyword arguments
            out.result # result of function call which is same as out.f(*out.args, **out.kwargs)
            out.files_widget # reference to FilesWidget created, not the same as fw because it is a new instance
        .. note::
            If you don't need to interpret the result of the function call, you can use the @self.interact decorator instead.
        """
        # Make new FilesWidget with same parameters, to allow multiple interact calls
        new_fw = self.__class__(base_path = self._widgets['input'].value, glob = self._widgets['glob'].value, exclude = self._widgets['exclude'].value)
        info = ipw.HTML().add_class('FW-Progess')
        
        def interact_func(filename, **kwargs):
            if filename: # This would be None if no file is selected
                info.value = _progress_svg
                try: 
                    start = time()
                    print(f'Running {func.__name__}({filename!r}, {kwargs})') # it also serves as removing the output errors
                    func(Path(filename).absolute(), **kwargs) # Have Path object absolue if user changes directory
                    print(f'Finished in {time() - start:.3f} seconds.')               
                finally:
                    info.value = ''
        
        out = ipw.interactive(interact_func, options, filename = new_fw._widgets['files'], **kwargs)
        
        out.files_widget = new_fw # save reference to FilesWidget
        out.output_widget = out.children[-1] # save reference to output widget for other widgets to use
        
        if options.get('manual',False):
            out.interact_button = out.children[-2] # save reference to interact button for other widgets to use
        
        output = out.children[-1] # get output widget
        output.clear_output(wait = True) # clear output by waiting to avoid flickering, this is important
        output.layout = ipw.Layout(overflow = 'auto', max_height = '100%', width = '100%') # make output scrollable and avoid overflow
        
        others = out.children[1:-1] # exclude files_dd and Output widget
        _style = '''<style>
        .FilesWidget-Interact {max-height:90vh;width:100%;}
        .FilesWidget-Interact > div {overflow:auto;max-height:100%;padding:8px;}
        .FilesWidget-Interact > div:first-child {width:40%}
        .FilesWidget-Interact > div:last-child {width:60%}
        .FilesWidget-Interact .FW-Progess {position:absolute !important; left:50%; top:50%; transform:translate(-50%,-50%); z-index:1}
        </style>'''
        if others:
            others = [ipw.HTML(f'<hr/>{_style}'), *others]
        else:
            others = [ipw.HTML(_style)]
            
        if other_controls and not isinstance(other_controls, (list,tuple)):
            raise TypeError('other_controls must be a list or tuple of widgets.')

        
        if other_widgets and not isinstance(other_widgets, (list,tuple)):
            raise TypeError('other_widgets must be a list or tuple of widgets.')
        
        if other_widgets:
            out_collapser = ipw.Checkbox(description = 'Hide output widget', value = False)
            def toggle_output(change):
                if out_collapser.value:
                    output.layout.height = '0px' # dont use display = 'none' as it will clear widgets and wont show again
                else:
                    output.layout.height = 'auto'
            out_collapser.observe(toggle_output, 'value')
            others.append(out_collapser)
            
        # This should be below output collapser
        others = [*others, ipw.HTML(f'<hr/>'), *(other_controls or [])] # add hr to separate other controls
            
        out.children = [HBox([ # reset children to include new widgets
            VBox(children = [new_fw, VBox(others)]), # other widgets in box to make scrollable independent file selection 
            VBox(children = [Box([output]), *(other_widgets or []), info]), # output in box to make scrollable, 
        ]).add_class('FilesWidget-Interact')]
        out.layout.max_height = max_height # important for every widget separately
        return out
        
    def interact(self, other_widgets =  None, other_controls = None, options = {'manual':False}, max_height = '90vh', **kwargs):
        """
        Interact with a function that takes a selected Path as first argument.
        A CSS class 'FilesWidget-Interact' is added to the final widget to let you style it.    
        
        Parameters
        ----------
        other_widgets : list/tuple of any displayable widget. These are placed below the output widget of interact.
            For example you can add plotly's FigureWidget that updates based on the selection, but is not part of the function, so it is displayed only once.
        other_controls : list/tuple, default is None. If not None, these are assumed to be ipywidgets and are placed below the widgets created by kwargs. These are not passed to the decorated function.
        options : dict, default is {'manua':False}. If True, the decorated function is not called automatically, and you have to call it manually on button press. You can pass button name as 'manual_name' in options.
        max_height : str, default is '90vh'. Max height of the final widget. This is important to avoid very long widgets.
        
        kwargs are passed to ipywidgets.interactive and decorated function. Resulting widgets are placed below the file selection widget.
        
        `other_widgets` can be controlled by `other_controls` externally. For example, you can add a button to update a plotly's FigureWidget.
        
        The decorated function can be called later separately as well, and has .args and .kwargs attributes to access the latest arguments 
        and .result method to access latest. For a function `f`, `f.result` is same as `f(*f.args, **f.kwargs)`.
        
        .. highlight:: python
        .. code-block:: python
        
            fw = FilesWidget()
            @fw.interact(x = False)
            def f(path,x):
                print('path:',path)
                print('Path Type: ', type(path))
                print('x: ',x)
        
        .. note::
            Use self.interactive to get a widget that stores the argements and can be called later in a notebook cell.
        """
        def inner(func):
            display(self.interactive(func, other_widgets = other_widgets, other_controls = other_controls, options = options, max_height = max_height,**kwargs))
            return func
        return inner 
    
    def summarize(self, func, **kwargs):
        """Summarize the results from all selected files using a function that takes a Path object as first arguement.
        kwargs are passed to function. Returns a dataframe."""
        return summarize({key: value for key,value in zip(self._widgets['files'].options, self._files)}, func, **kwargs)


class PropsPicker(ipw.VBox):
    def __init__(self, system_summary):
        super().__init__()
        self._widgets = {
            'spin': ipw.BoundedIntText(min=0,max=4), # should be fixed by summary.NSETS, define that
            'atoms': ipw.SelectionSlider(options = ['Atom-1'],description='Atoms'),
            'orbs': ipw.SelectionSlider(options= ['Orbs-1'],description = 'Orbs')
        }
        self._atoms = {}
        self._orbs = {}
        self._process(system_summary)
        
    def _process(self, system_summary):
        if not hasattr(system_summary, 'orbs'):
            self.children = [ipw.HTML('❌ No projection data found!')]
            return None
        
        label = lambda name: ipw.Label(name,layout = ipw.Layout(width='3.5em'))
        self.children = [
            self._widgets['atoms'],
            self._widgets['orbs'],
            ipw.HBox([label('Spin:'),self._widgets['spin']]), 
        ]
        # self.layout.width = '17em'
        # for w in self._widgets.values():
        #     w.layout.width = '4.5em'
            
        self._orbs = {lab:idx for idx,lab in enumerate(system_summary.orbs)}
        self._widgets['orbs'].options = system_summary.orbs
            
        atoms = {}
        for key, tp in system_summary.types.to_dict().items():
            for n, v in enumerate(tp, start = 1):
                atoms[f'{key}{n}'] = v
        self._atoms = atoms
        self._widgets['atoms'].options = list(atoms.keys())
        
    def update(self, system_summary):
        return self._process(system_summary)
            
    @property
    def props(self):
        items = {k:w.value for k,w in self._widgets.items()}
        items['atoms'] = sorted([self._atoms[items['atoms']]])
        items['orbs'] = sorted([self._orbs[ items['orbs']]])
        items['label'] = f"{self._widgets['atoms'].value}-{self._widgets['orbs'].value}"
        return items
    
class PropsPickers(ipw.VBox):
    def __init__(self, system_summary, func, N = 3):
        super().__init__()
        self._modifiers = tuple(ipw.Button(description=s) for s in ['+','-'])
        self._linked = ipw.Dropdown(options = [str(i+1) for i in range(N)] if N!=3 else ('Red', 'Green', 'Blue'),description = 'Projection' if N != 3 else 'Color')
        self._stacked = ipw.Stack(children =  tuple(PropsPicker(system_summary) for _ in range(N)),selected_index = 0)
        self._button = ipw.Button(description = 'Click Me')
        self._button.on_click(func)
        
        for child in self._stacked.children:
            child.children[-1].children = [*child.children[-1].children, self._button]
        ipw.link((self._linked, 'index'), (self._stacked, 'selected_index'))
        self.children = [self._linked, *self._modifiers,self._stacked]
        
    def update(self, system_summary):
        for child in self._stacked.children:
            child.update(system_summary)
    
    @property
    def projections(self):
        out = {}
        for child in self._stacked.children:
            props = child.props
            if props['atoms'] and props['orbs']: # empty not allowed
                out[props['label']] = (props['spin'], props['atoms'], props['orbs'])
        return out

# Cell
class InputGui:
    def __init__(self,sys_info=None,theme_colors = None,height=400):
        """
        - Creates a GUI interface for input/selection of orbitals/atoms projection.
        - **Parmeters**
            - theme_colors : None,Any of ipyvasp.[dark,light,simple]_colors.
            - height     : Height of Grid box, Can set to None for auto-resizing.
            - sys_info   : `export_vasprun().sys_info`. Can change later using `self.update_options` mthod.
        - **Output Parameters**
            - output: Dictionary that contains kwargs for plot functions.
            - html  : A widget which can be used to bserve change in output, used in `VasprunApp`.
        """
        self.sys_info = sys_info if sys_info else serializer.Dict2Data({'fields':['s'], 'types':{'A': range(1)},})
        self.output = dict(atoms = [[],[],[]],orbs = [[],[],[]],labels = ['','',''])

        layout = Layout(width='30%')
        l_width = Layout(width='20%')
        self.html = ipw.HTML() # For Display in Big App as well. Very important
        self._dds = {
            'elms': Dropdown(layout=layout),
            'orbs': Dropdown(layout=layout),
            'rgb' : Dropdown(options=[('Red',0),('Green',1),('Blue',2)],value=0,layout=layout)
            }
        self._texts = {
            'orbs' : Text(value='', layout=layout,continuous_update=False), 
            'elms' : Text(value='', layout=layout,continuous_update=False),
            'label': Text(value='', layout=layout,continuous_update=False)
            }
        self.update_options(self.sys_info) # In start if given

        _class = 'custom-'+''.join(np.random.randint(9,size=(23,)).astype(str)) #Random class
        html_style = css_style(theme_colors,_class = _class) if theme_colors else ''
        self.box = VBox([ipw.HTML(html_style),
                self.html,
                HBox([Label('Color: ',layout=l_width), self._dds['rgb'],
                      Label('Label: ',layout=l_width),self._texts['label']
                    ]).add_class('borderless').add_class('marginless'),
                HBox([Label('Ions: ',layout=l_width),self._dds['elms'],
                      Label('::>>:: ',layout=l_width),self._texts['elms']
                    ]).add_class('borderless').add_class('marginless'),
                HBox([Label('Orbs: ',layout=l_width),self._dds['orbs'],
                      Label('::>>:: ',layout=l_width),self._texts['orbs']
                    ]).add_class('borderless').add_class('marginless')
                ],layout=Layout(height="{}px".format(height or 400))
                ).add_class(_class).add_class('marginless')


        #Obsever
        self._dds['rgb'].observe(self.__see_input,'value')
        self._texts['label'].observe(self.__read_pro,'value')
        self._texts['orbs'].observe(self.__read_pro,'value')
        self._texts['elms'].observe(self.__read_pro,'value')
        # Link
        ipw.dlink((self._dds['elms'],'value'),(self._texts['elms'],'value'))
        ipw.dlink((self._dds['orbs'],'value'),(self._texts['orbs'],'value'))


    def update_options(self,sys_info=None):
        if sys_info:
            orbs_opts = [(str(i)+': '+item,str(i)) for i,item in enumerate(sys_info.fields)]
            if len(sys_info.fields) == 9:
                orbs_opts = [*orbs_opts,('1-3: p','1-3'),('4-8: d','4-8')]
            if len(sys_info.fields) == 16:
                orbs_opts = [*orbs_opts,('9-15: f','9-15')]
            max_ind = len(sys_info.fields)-1
            orbs_opts = [('0-{}: All'.format(max_ind), "0-{}".format(max_ind)),*orbs_opts]
            inds = sorted(np.ravel(list(sys_info.types.values())))
            ions_opts = [("{}-{}: {}".format(v[0],v[-1],k),"{}-{}".format(
                                    v[0],v[-1])) for k,v in sys_info.types.items()]
            self._dds['elms'].options = [*ions_opts,('0-{}: All'.format(inds[-1]),'0-{}'.format(inds[-1]))]
            self._dds['orbs'].options = orbs_opts
            self.sys_info = sys_info # Update it as well.

    def __read_pro(self,btn):
        def read(cell_value):
            _out = []
            for v in (cell_value.split(",") if cell_value else ''):
                if v and '-' in v:
                    i, f = [int(k) for k in v.split("-")]
                    _out = [*_out,*list(range(i,f+1))]
                elif v:
                    _out = [*_out,int(v)]
            return _out

        index = self._dds['rgb'].value
        self.output['atoms'][index] = read(self._texts['elms'].value)
        self.output['orbs'][index] = read(self._texts['orbs'].value)
        _text,_ion,_orb = self._texts['label'].value,self._texts['elms'].value,self._texts['orbs'].value
        self.output['labels'][index] = _text if _text else "{}:{}".format(_ion,_orb)
        self.html.value = """<div style='border: 2px solid {0}!important;
                             background-color:{0} !important;'> </div>
                             """.format(self._dds['rgb'].label.lower())
        sleep(0.3)
        self.html.value = ''

    def __see_input(self,change):
        # Unobserve first to avoid overwriting
        self._texts['label'].unobserve(self.__read_pro,'value')
        self._texts['orbs'].unobserve(self.__read_pro,'value')
        self._texts['elms'].unobserve(self.__read_pro,'value')

        # Look up while not observing
        x = self._dds['rgb'].value
        self._texts['elms'].value = ','.join([str(i) for i in self.output['atoms'][x]])
        self._texts['orbs'].value = ','.join([str(i) for i in self.output['orbs'][x]])
        self._texts['label'].value = self.output['labels'][x]
        # Observe Back Again
        self._texts['label'].observe(self.__read_pro,'value')
        self._texts['orbs'].observe(self.__read_pro,'value')
        self._texts['elms'].observe(self.__read_pro,'value')

    def show(self):
        return self.box

# Cell
#mouse event handler
def _click_data(sel_en_w,Fermi,data_dict,fig,bd_w):
    def handle_click(trace, points, state):
        if points.ys != []:
            v_clicked = points.ys[0] if bd_w.value=='Bands' else points.xs[0]
            val = np.round(float(v_clicked) + Fermi,6) #exact value

            for key in sel_en_w.options:
                if key in sel_en_w.value and key != 'None':
                    data_dict[key] = val # Assign value back

            # Update E_gap, SO etc
            if data_dict['VBM'] and data_dict['CBM']:
                data_dict['E_gap'] = np.round(data_dict['CBM'] - data_dict['VBM'], 6)
            if data_dict['so_max'] and data_dict['so_min']:
                data_dict['Δ_SO'] = np.round(data_dict['so_max'] - data_dict['so_min'], 6)
            # Cycle energy types on graph click and chnage table as well unless it is None.
            if sel_en_w.value == 'CBM': # Avoid accidental SO calculation
                sel_en_w.value = 'None'
            if sel_en_w.value != 'None': # Keep usually as None
                _this = sel_en_w.options.index(sel_en_w.value)
                _next = _this + 1 if _this < len(sel_en_w.options) - 1 else 0
                sel_en_w.value = sel_en_w.options[_next] #To simulate as it changes

    for trace in fig.data:
        trace.on_click(handle_click)

# Display Table
def _tabulate_data(data_dict):
    new_dict = {k:v for k,v in data_dict.items() if v != '' and k not in ['sys','so_max','so_min']}
    ls = list(new_dict.keys())
    ds = list(new_dict.values())

    if len(ls) % 2 != 0:
        ls.append('')
        ds.append('')

    tab_data = [ls[:int(len(ls)/2)],ds[:int(len(ls)/2)],ls[int(len(ls)/2):],ds[int(len(ls)/2):]]

    htm_string = """<style>table {border-collapse: collapse !important;
      min-width: 100% !important;
      margin: 1px 1px 1px 1px !important;
      font-size: small !important;
      font-family: "Times New Roman", "Times", "serif" !important;}
      th, td {text-align: center !important;
      padding: 0px 8px 0px 8px !important;}
      tr { width: 100% !important;}
      tr:nth-child(odd) {font-weight:bold !important;}
      </style>"""
    htm_string += "<table><tr>{}</tr></table>".format( '</tr><tr>'.join(
                   '<td>{}</td>'.format('</td><td>'.join(str(_) for _ in row)) for row in tab_data) )
    return htm_string

# Send Data
def _save_data(out_w1,data_dict):
    out_f = os.path.join(os.path.split(out_w1.value)[0],'result.json')
    serializer.dump(data_dict,dump_to='json',outfile=out_f)

# Cell
def _generate_summary(paths_list):
    # Make Data Frame
    result_paths = []
    if paths_list:
        for item in paths_list:
            if item and os.path.isdir(item):
                result_paths.append(os.path.join(item,'result.json'))
            elif item and os.path.isfile(item):
                result_paths.append(os.path.join(os.path.split(item)[0],'result.json'))
    
    def load_data(path):
        try:
            return serializer.load(path)
        except:
            return {} # If not found, return empty dictionary
    
    return summarize(result_paths,load_data)
    
# Cell

#export
class VasprunApp:
    """
    Display a GUI for vasp output analysis. `self.theme_colors` can be used to edit custom theme.

    **Usage Example**
    ```python
    import ipyvasp as pp
    va = pp.VasprunApp()
    va.set_options(
        cache_data = False, #Turn off cache globally.
        mode = 'bands', #Change graph mode from 'markers' to 'bands'. Setting it to 'lines' is not recommended in live graph, it could hang all UI.
        interp = (5,3), # int or list/tuple of (n,k) for interpolation. If int, n is number of points to interpolate. If list/tuple, n is number of points and k is the order of spline.
    
    )
    va.show() #Displays App and do work!
    va.theme_colors = pp.dark_colors #Set theme to dark externally and edit dictionary values to make your own theme
    va.splot(**kwargs) #Get matplotlib plot of current data.
    va.df #After you do some analysis and hit `Project Summary` button, get DataFrame or directly by.df
    va.fig #Get current fig in Notebook cell.
    ```
    """
    _output = ipw.Output().add_class('output')
    def __init__(self,height = 610):
        self.height = height
        tab = ipw.Tab(layout = ipw.Layout(min_height=f'{height}px', max_height='100vh',
                                           min_width='700px', max_width='100vw')
            ).add_class('marginless').add_class('borderless') # Main Tab
        try:
            for i,item in enumerate(['Home','Graphs','STD(out/err)']):
                tab.set_title(i,item)
        except:
            tab.titles = ['Home','Graphs','STD(out/err)']
        self._main_class = 'custom-'+''.join(np.random.randint(9,size=(22,)).astype(str)) #Random class
        self._tab     = tab.add_class(self._main_class) # Main layout
        self._data   = None # Export vasprun object.
        self._path = None # current path
        self._fig    = go.FigureWidget() # plotly's figure widget
        self._fig.update_layout(autosize=True)
        self._result = {'sys':'','V':'','a':'','b':'','c':'',
                     'VBM':'','CBM':'','so_max':'','so_min':''} # Table widget value

        self._files_gui = FilesWidget(glob = 'vaprun.xml')
        self._files_dd = self._files_gui.dropdown
        self._InGui  = InputGui(height=None)
        self._input  = {'Fermi': 0} # Dictionary for input Should be zero, not None
        self._fig_gui = HBox() # Middle Tab
        self.theme_colors = light_colors.copy() # Avoid Modification
        # Permeannet Parameters
        self._idos_kws   = dict(colormap='RGB',tdos_color=(0.5, 0.95, 0),linewidth=2,fill_area=True,
                               spin='both',interp = None,title=None)
        self._ibands_kws = dict(mode='bands',skipk=None,maxwidth=6,title=None,interp=None)
        self._evr_kws = dict(skipk=None,elim=[])
        self._cache_data = True

        l_btn = ipw.Layout(width='max-content')
        self._buttons = {'load_data' : Button(description='Load Data',layout=l_btn,tooltip='Load and Cache Data'),
                        'load_graph': Button(description='Update Graph',layout=l_btn,tooltip='Create Graph'),
                        'confirm'   : Button(description='Confirm Delete',layout=l_btn,icon='trash'),
                        'summary'   : Button(description='Project Summary',layout=l_btn,tootltip='Make DataFrame'),
                        'expand'    : Button(icon = "fa-expand",layout=l_btn,tooltip='Expand Fig'),
                        'save_fig'  : Button(description='Save Fig',icon='download',layout=l_btn,tooltip='')
                        }

        b_out = Layout(width='30%')
        en_options = ['VBM','CBM','so_max','so_min','None']
        self._dds   = {'band_dos': Dropdown(options=['Bands','DOS'],value='Bands',
                                                layout= Layout(width='80px')),
                      'en_type' : Dropdown(options = en_options,value='None',layout=b_out),
                      'cache'   : Dropdown(options=['Table Data','PWD Cache','All Cache','None'],
                                            value='None',layout=b_out),
                      'theme'   : Dropdown(options=['Default','Light','Dark','Custom'],
                                            value='Default',layout=l_btn),
                      'style'   : Dropdown(options=["plotly", "plotly_white", "plotly_dark",
                                    "ggplot2", "seaborn", "simple_white", "none"],layout=l_btn),
                                    }

        self._texts = {'kticks': Text(value='',layout=b_out,continuous_update=False),
                      'ktickv': Text(value='',layout=b_out,continuous_update=False),
                      'kjoin' : Text(value='',layout=b_out,continuous_update=False),
                      'elim'  : Text(value='',layout=b_out,continuous_update=False),
                      'xyt'   : Text(value='',continuous_update=False),
                      'load_elim'  : Text(value='-5,5',layout = Layout(width='5em'),continuous_update=False)
                      }
        self._htmls = {'theme': ipw.HTML(css_style(light_colors,_class = self._main_class)),
                      'table': ipw.HTML()}

        # Observing
        self._InGui.html.observe(self.__update_input,"value")
        self._InGui.html.observe(self._warn_to_load_graph,"value")
        self._files_dd.observe(self._warn_to_load_graph,"value")
        self._texts['kticks'].observe(self._warn_to_load_graph,"value")
        self._dds['band_dos'].observe(self._warn_to_load_graph,"value")
        self._dds['band_dos'].observe(self.__update_input,"value")
        self._texts['kticks'].observe(self.__update_xyt,"value")
        self._texts['elim'].observe(self.__update_xyt,"value")
        self._texts['xyt'].observe(self.__update_xyt)
        self._dds['theme'].observe(self.__update_theme,"value")
        self._dds['style'].observe(self.__update_plot_style,"value")
        self._files_dd.observe(self.__load_previous,"value")
        self._buttons['load_graph'].on_click(self.__load_previous,"value")
        self._buttons['load_data'].on_click(self.__on_load)
        self._dds['band_dos'].observe(self.__figure_tab,"value")
        self._files_dd.observe(self.__update_table,'value')
        self._buttons['load_data'].observe(self.__update_table,'value')
        self._dds['en_type'].observe(self.__update_table,"value") # This works from _click_data
        self._buttons['summary'].on_click(self.__df_out)
        self._buttons['confirm'].on_click(self.__deleter)
        self._buttons['save_fig'].on_click(self.__save_connected)
        self._buttons['expand'].on_click(self.__expand_fig)
        self._buttons['load_graph'].on_click(self.__update_graph)
        self._texts['load_elim'].observe(self.__elim_changed,"value")
        # Build Layout
        self.__build()
        self._tab.on_displayed(self._on_displayed)

    @property
    def data(self): return self._data

    @property
    def fig(self): return self._fig

    @property
    def result(self): return self._result

    @property
    def input(self): return self._input

    @property
    def htmls(self): return self._htmls

    @property
    def texts(self): return self._texts

    @property
    def dds(self): return self._dds

    @property
    def buttons(self): return self._buttons

    @property
    def files_dd(self): return self._files_dd

    @property
    def path(self): return self._path

    @property
    def output(self): return self.__class__._output

    def set_options(self, cache_data = True, # general options
        mode = 'bands', maxwidth = 6, skipk = None, # bands only keywords
        interp = None, title = None, # Mixed keywords
        colormap='RGB',tdos_color=(0.5, 0.95, 0),linewidth=2,fill_area=True, spin='both' # DOS only keywords
        ):
        self._cache_data = cache_data
        if mode not in ['bands','markers','lines']:
            raise ValueError("mode must be 'bands','markers','lines'")
        # bands only keywords
        self._ibands_kws['mode'] = mode
        self._ibands_kws['maxwidth'] = maxwidth
        self._ibands_kws['skipk'] = skipk

        if interp and not isinstance(interp,(list,tuple,np.integer,int)):
            raise ValueError("interp must be int or list/tuple of (n,k)")
        if isinstance(interp,(list,tuple)) and len(interp) != 2:
            raise ValueError("interp must be int or list/tuple of (n,k)")
        # Mixed keywords
        self._ibands_kws['interp'] = interp
        self._idos_kws['interp'] = interp
        self._idos_kws['title'] = title
        self._ibands_kws['title'] = title

        if spin not in 'updownboth':
            raise ValueError("spin must be in ('up','down','both')")
        # DOS only keywords
        self._idos_kws['colormap'] = colormap
        self._idos_kws['tdos_color'] = tdos_color
        self._idos_kws['linewidth'] = linewidth
        self._idos_kws['fill_area'] = fill_area
        self._idos_kws['spin'] = spin

        self._evr_kws['skipk'] = skipk # Useful


    def _on_displayed(self, change = None):
        self._tab.selected_index = 1
        self._fig_gui.layout.width = '95%' # Just to send a signal to resize the graph
        self._fig_gui.layout.width = '100%' # Just to send another signal for figure size
        self._tab.selected_index = 0

    def __elim_changed(self,change):
        # Delete Cache and Data to make user reload data
        self._dds['cache'].value = 'PWD Cache'
        self._buttons['confirm'].click()

    def __check_lsorbit(self):
        if self._data:
            lsorbit = self._data.sys_info.incar.to_dict().get('LSORBIT','F')
            options = ['VBM','CBM','None']
            if lsorbit in 'T':
                options = ['VBM','CBM','so_max','so_min','None']
            self._dds['en_type'].options = options
            self._dds['en_type'].value = 'None'

    def _warn_to_load_graph(self, change = None):
        if change['owner'] == self._texts['kticks']:
            if '|' not in self._texts['kticks'].value:
                return None # No need to warn if no broken path
                
        self._buttons['load_graph'].icon = 'refresh'
        self._buttons['load_graph'].style.button_color = 'yellow'
        self._buttons['load_graph'].description = 'Update Graph'

    def set_theme_colors(self,theme_colors):
        "Get self.theme_colors and after edit set back"
        if 'dds' in self.__dict__.keys():
            self._dds['theme'].value = 'Custom'
        if 'htmls' in self.__dict__.keys():
            self._htmls['theme'].value = css_style(theme_colors)

    def __figure_tab(self,change):
        l_out = Layout(width='20%')
        cache_box = HBox([Label('Delete Cache:'),self._dds['cache'],self._buttons['confirm']]
                        ).add_class('marginless')
        upper_box = VBox([
                HBox([Label('File:',layout=Layout(width='50px')),self._files_dd
                    ]).add_class('borderless').add_class('marginless'),
                HBox([Label('View:',layout=Layout(width='50px')),
                        self._dds['band_dos'],
                        Label('elim:',layout=Layout(width='3em')),
                        self._texts['load_elim'],
                        self._buttons['load_data'],
                    ]).add_class('borderless').add_class('marginless')
                ]).add_class('marginless').add_class('borderless')

        points_box = HBox([Box([Label('E Type:',layout=Layout(min_width='5em')),
                                self._dds['en_type'],
                    ],layout = Layout(min_width='50%')).add_class('marginless').add_class('borderless'),
                    self._buttons['load_graph']
                    ],layout=Layout(width='100%')).add_class('marginless')
        in_box = VBox([self._InGui.box,
                    ]).add_class('marginless').add_class('borderless')
        top_right = HBox([self._buttons['load_graph'],
                          Label('Style:'),
                          self._dds['style'],
                          Label('Theme:'),
                          self._dds['theme'],
                          self._buttons['expand']
                    ]).add_class('marginless')
        fig_box = Box([self._fig],layout=Layout(min_height='380px')).add_class('marginless')
        right_box = VBox([top_right,fig_box,self._htmls['table']
                 ],layout=Layout(min_width='60%')).add_class('marginless').add_class('borderless')


        if 'Bands' in self._dds['band_dos'].value:
            in_box.children = [Label('---------- Projections ----------'),self._InGui.box,
                               Label('---- Other Arguments/Options ----'),
                      VBox([HBox([Label('kticks: ',layout=l_out),
                                  self._texts['kticks'],
                                  ]).add_class('borderless').add_class('marginless'),
                      HBox([
                            Label('E Range: ',layout=l_out),
                            self._texts['elim']
                           ]).add_class('marginless').add_class('borderless')
                      ]).add_class('marginless')]
            right_box.children = [top_right,fig_box,points_box]

        else:
            in_box.children = [Label('---------- Projections ----------'),self._InGui.box,
                               Label('---- Other Arguments/Options ----'),
                      HBox([Label('E Range:',layout=l_out),
                      self._texts['elim'],
                      ]).add_class('marginless')]
            right_box.children = [top_right,fig_box,points_box]
            self._dds['en_type'].value = 'None' # no scatter collection in DOS.

        left_box = VBox([upper_box,
                        in_box,
                        HBox([Label('X, Y, Title'),self._texts['xyt']]).add_class('borderless'),
                        HBox([Label('Options:'),self._buttons['summary'],self._buttons['save_fig']]),
                        cache_box,
                        self._htmls['table']],layout=Layout(max_width='40%'),
                        ).add_class('marginless').add_class('borderless')
        self._fig_gui.children = (left_box,right_box)
        return self._fig_gui # Return for use in show

    @_output.capture()
    def __build(self):
        intro_html = ipw.HTML(("<h2>ipyvasp</h2><p>Filter files here and switch tab to Graphs. "
                               "You can create cache ahead of time to load quickly while working. "
                               "If anything does not seem to work, see the error in STD(out/err) tab. "
                               "<a href=https://massgh.github.io/ipyvasp/Widgets.html#VasprunApp target='_blank'> See More</a> "
                               "</p><marquee style='color:blue'>ipyvasp GUI based on ipywidgets!</marquee>"))
        header_box = HBox([intro_html,
                           Label('Theme:',layout=Layout(width='80px')),
                           self._dds['theme']
                    ]).add_class('marginless').add_class('borderless')
        summary_gui = HBox([ipw.Label(),
                            self._buttons['summary']]
                            ).add_class('borderless')
        intro_box = VBox([self._htmls['theme'],
                      header_box,
                      self._files_gui,
                      summary_gui]
                      ).add_class('marginless').add_class('borderless').add_class('marginless')
        self._fig_gui = self.__figure_tab(1) #Start
        self._tab.children = (intro_box,
                             self._fig_gui,
                             VBox([HBox([ipw.HTML("<h3>Functions Logging/Output</h3>"),
                                          Box([
                                          Label('Theme:',layout=Layout(width='80px')),
                                          self._dds['theme']],layout=Layout(left='50%')).add_class('borderless')
                                          ]).add_class('borderless').add_class('marginless'),
                                    self.__class__._output])
                             )
        self._dds['style'].value = 'plotly' # to trigger first callback on graph.
        self.app = self._tab #Need to access it
        self.__update_theme(True) #Good option in jupyterlab for following theme.

    def show(self):
        return display(self._tab)

    def _ipython_display_(self):
        self.show()

    def __fill_ticks(self):
        kpath = os.path.join(os.path.split(self._files_dd.value)[0],'KPOINTS')
        tvs = sio.read_kticks(kpath) #ticks values segments
        if tvs: #If is must, if not present, avoid overwritting custom input
            text_ticks = ', '.join('{}:{}'.format(k if isinstance(k,(int,np.integer)) else '{}|{}'.format(*k),v) for k,v in tvs)
            self._texts['kticks'].value = text_ticks
        
    def __update_theme(self,change):
        if self._dds['theme'].value == 'Dark':
            self._htmls['theme'].value = css_style(dark_colors,_class=self._main_class)
            self._fig.update_layout(template='plotly_dark')
            self._dds['style'].value = 'plotly_dark'
        elif self._dds['theme'].value == 'Light':
            self._htmls['theme'].value = css_style(light_colors,_class=self._main_class)
            self._fig.update_layout(template='ggplot2')
            self._dds['style'].value = 'ggplot2'
        elif self._dds['theme'].value == 'Custom':
            self._htmls['theme'].value = css_style(simple_colors,_class=self._main_class)
            self._fig.update_layout(template='none')
            self._dds['style'].value = 'none'
        else:
            self._htmls['theme'].value = css_style(default_colors,_class=self._main_class)
            self._fig.update_layout(template='plotly')
            self._dds['style'].value = 'plotly'

    def __update_plot_style(self,change):
        self._fig.update_layout(template = self._dds['style'].value)

    @_output.capture(clear_output=True,wait=True)
    def __load_previous(self,change):
        path = self._files_dd.value
        try:
            _dir = os.path.split(path)[0]
            r_f = os.path.join(_dir,'result.json')
            self._result = serializer.load(r_f)
            self.__update_table(change = None)
            print('Previous Analysis loaded in Table for {}'.format(path))
        except:
            print('Previous Analysis does not exist for {}'.format(path))

    @_output.capture(clear_output=True,wait=True)
    def __read_data(self,poscar=None,sys_info=None):
        if sys_info != None:
            self._result["sys"] = sys_info.SYSTEM
        if poscar != None:
            self._result["V"] = np.round(poscar.volume,6)
            a,b,c = np.round(np.linalg.norm(poscar.basis,axis=1),6)
            self._result["a"] = a
            self._result["b"] = b
            self._result["c"] = c

    @_output.capture(clear_output=True,wait=True)
    def __on_load(self,button):
        if self._data and self._files_dd.value == self._path: # Same load and data exists, keeps in fast
            print('Data already loaded')
            self._buttons['load_data'].description = 'Data already loaded'
            sleep(1)
            self._buttons['load_data'].description = 'Load Data'
            return None

        self.__fill_ticks() # First fill ticks, then update input
        self.__update_input(change=None) # Fix input right here.
        self.__load_previous(change=button) # previous calculations.
        self._tab.selected_index = 2
        self._buttons['load_data'].description='Loading ...'
        _dir = os.path.split(self._files_dd.value)[0] # directory
        try:
            sys_info = serializer.load(os.path.join(_dir,'sys_info.pickle'))
            self._data = serializer.load(os.path.join(_dir,'vasprun.pickle'))
            print('Cache Loaded')
        except:
            print('Trying Loading from Python ...')
            elim = self._texts['load_elim'].value.split(',')[:2] # First two atoms
            if len(elim) == 2:
                self._evr_kws['elim'] = [float(e) for e in elim]
            self._data = vp.export_vasprun(self._files_dd.value, **self._evr_kws)
            if self._cache_data:
                print('Caching From: {}'.format(self._files_dd.value)) #Cache result
                serializer.dump(self._data.sys_info,outfile=os.path.join(_dir,'sys_info.pickle'))
                serializer.dump(self._data,outfile=os.path.join(_dir,'vasprun.pickle'))

            sys_info = self._data.sys_info # required here.
            print('Done')

        _ = self.__read_data(self._data.poscar,sys_info) # Update Table data on load
        self._tab.selected_index = 1
        # Revamp input dropdowns on load  ==========
        self._InGui.update_options(sys_info=sys_info) #Upadate atoms/orbs/labels
        #===========================================
        self._buttons['load_data'].description='Load Data'
        self._path = self._files_dd.value # Update in __on_load or graph to make sure data loads once
        self._buttons['load_data'].tooltip = "Current System\n{!r}".format(self._data.sys_info)
        self.__update_input(change=None) # Update to have new Fermi value
        self._warn_to_load_graph()

    @_output.capture(clear_output=True,wait=True)
    def __update_input(self,change):
        self._input.update(self._InGui.output)
        elim_str  = [v for v in self._texts['elim'].value.split(',') if v!='']
        if self._data:
            self._input['Fermi'] = float(self._data.fermi)
        self._input['elim'] = [float(v) for v in elim_str if v!='-'][:2] if len(elim_str) >= 2 else None
        if self._dds['band_dos'].value == 'Bands':
            kticks = {}
            hsk = [[v.strip() for v in vs.split(':')] for vs in self._texts['kticks'].value.split(',')]
            for k,v in hsk:
                kticks[k] = tuple([int(v.strip()) for v in k.split('|')]) if '|' in k else int(k)
            
            self._input['kticks'] = kticks
        else:
            self._input = {k:v for k,v in self._input.items() if k not in ['kticks']}
        #Update at last
        self._InGui.output = self._input
        self._buttons['load_graph'].tooltip = "Current Input\n{!r}".format(serializer.Dict2Data(self._input))


    @_output.capture(clear_output=True,wait=True)
    def __update_table(self,change):
        self._htmls['table'].value = _tabulate_data(self._result)
        _save_data(self._files_dd,self._result) # save data as well.

    @_output.capture(clear_output=True,wait=True)
    def __df_out(self,btn):
        self._tab.selected_index = 2
        self._buttons['summary'].description = 'See STD(out/err) Tab'
        display(self.df)
        print('Get above DataFrame by app_name.df\nNote: app_name is variable name assigned to VasprunApp()')
        self._buttons['summary'].description = 'Project Summary'

    @property
    def df(self):
        "Access Results of all calculations as DataFrame"
        paths = [v for (k,v) in self._files_dd.options]
        return _generate_summary(paths_list=paths)

    @_output.capture(clear_output=True,wait=True)
    def __deleter(self,btn):
        self._buttons['confirm'].description = 'Deleting ...'
        if self._files_dd.value:
            print('Deleting Selected Cache...')
            self.__clear_cache() # Deleting
            print('Done')
        self.__update_table(1) #Update when delete data
        self._buttons['confirm'].description='Confirm Delete'

    @_output.capture(clear_output=True,wait=True)
    def __update_xyt(self,change):
        if self._texts['xyt'].value:
            xyt_text = self._texts['xyt'].value.split(',')
            try:
                self._fig.update_xaxes(title=xyt_text[0])
                self._fig.update_yaxes(title=xyt_text[1])
                self._fig.update_layout(title=xyt_text[2])
            except: pass #do nothing else

        if self._texts['kticks'].value or self._texts['elim'].value:
            self.__update_input(change=None)
        if self._dds['band_dos'].value == 'Bands' and self._data:
            tickvals = [self._data.kpath[i if isinstance(i,(int,np.integer)) else i[0]] for i in self._input['kticks']]
            self._fig.update_xaxes(ticktext = list(self._input['kticks'].values()), tickvals = tickvals)
        if self._texts['elim'].value and self._input['elim'] != None and len(self._input['elim']) == 2:
            if self._dds['band_dos'].value == 'Bands':
                self._fig.update_yaxes(range = self._input['elim'])
            else:
                self._fig.update_xaxes(range = self._input['elim'])

    @_output.capture(clear_output=True,wait=True)
    def __save_connected(self,btn):
        s_p = os.path.split(self._files_dd.value)[0]
        filename = os.path.join(s_p,'ConnectedFig.html')
        filename = gu.prevent_overwrite(filename)
        self._buttons['save_fig'].description = 'Saving...'
        theme = self._htmls['theme'].value.replace(f'.{self._main_class}','')
        views = VBox([ipw.HTML(theme),self._fig,self._htmls['table']],
                layout=Layout(width='500px',height='490px')).add_class('borderless')
        embed_minimal_html(filename, views=[views], state=dependency_state([views]))
        self._buttons['save_fig'].description = 'Save Fig'
        self._buttons['save_fig'].tooltip = 'Recently Saved\n{!r}'.format(filename)

    @_output.capture(clear_output=True,wait=True)
    def __expand_fig(self,btn):
        self._tab.selected_index = 2
        self._dds['en_type'].value = 'None' # To avoid accidental clicks
        display(self._fig)
    # Garph
    @_output.capture(clear_output=True,wait=True)
    def __update_graph(self,btn):
        if (self._buttons['load_graph'].icon == 'check') and (self._data and self._files_dd.value == self._path):
            print('Graph is already updated with latest input!')
            self._buttons['load_graph'].description = 'Graph Already Updated'
            sleep(1)
            self._buttons['load_graph'].description = 'Latest Graph'
            return None

        path = self._files_dd.value
        if path:
            self.__fill_ticks() # First fill ticks, then update input
            self.__update_input(change=None) # Update input here as well
            self._tab.selected_index = 2
            self._fig.data = []
            if self._data and path == self._path: # Same load and data exists, keeps in fast
                print('Data already loaded')
            else:
                self._buttons['load_graph'].description = 'Loading Data...'
                try:
                    print('Trying to Load Cache for Graph ...')
                    file = os.path.join(os.path.split(path)[0],'vasprun.pickle')
                    self._buttons['load_graph'].description = file
                    self._data = serializer.load(file)
                except:
                    print('No cache found. Loading from file {} ...'.format(path))
                    elim = self._texts['load_elim'].value.split(',')[:2] # First two atoms
                    if len(elim) == 2:
                        self._evr_kws['elim'] = [float(e) for e in elim]
                    self._data = vp.export_vasprun(path, **self._evr_kws)

            self._buttons['load_graph'].description = 'Updating Graph...'
            print('Done')

            self._path  = self._files_dd.value #update here or __on_load. Useful to match things
            _ = self.__read_data(self._data.poscar,self._data.sys_info) # Update Table data
            self.__check_lsorbit() # Check if LSORBIT is on, then set options accordingly

            self._input['Fermi'] = float(self._data.fermi) # Update Fermi before plot
            if self._dds['band_dos'].value == 'Bands':
                fig = ip.iplot_rgb_lines(path_evr=self._data,**self._input,**self._ibands_kws)
            else:
                self._dds['en_type'].value = 'None' # Avoid random clicks
                fig = ip.iplot_dos_lines(path_evr=self._data,**self._input,**self._idos_kws) # input auto-modified

            self._tab.selected_index = 1
            ip.iplot2widget(fig,self._fig, template = self._dds['style'].value) # Update figure
            _click_data(self._dds['en_type'],self._input['Fermi'],self._result,self._fig,self._dds['band_dos']) # click after updating fermi

            self._buttons['load_graph'].icon = 'check'
            self._buttons['load_graph'].description = 'Latest Graph'
            self._buttons['load_graph'].style.button_color = 'transparent'

    @_output.capture(clear_output=True,wait=True)
    def __clear_cache(self):
        self._tab.selected_index = 2
        _dir = os.path.split(self._files_dd.value)[0]
        if 'Table' in self._dds['cache'].value:
            for k in self._result.keys(): # Avoid deleting V,a,b,Fermi
                if k not in ['sys','V','a','b','c']:
                    self._result[k] = ''
        if 'PWD' in self._dds['cache'].value:
            _files = [os.path.join(_dir,f) for f in ['sys_info.pickle','vasprun.pickle']]
            _ = [[print("Deleting", _file),os.remove(_file)] for _file in _files if os.path.isfile(_file)]
            self._data =  None
            self._warn_to_load_graph(change=None)
        if 'All' in self._dds['cache'].value:
            for (key, value) in self._files_dd.options:
                _dir = os.path.split(value)[0]
                _files = [os.path.join(_dir,f) for f in ['sys_info.pickle','vasprun.pickle']]
                _ = [[print("Deleting", _file),os.remove(_file)] for _file in _files if os.path.isfile(_file)]
            self._data =  None
            self._warn_to_load_graph(change=None)

        self._tab.selected_index = 1

    def iplot(self,**kwargs):
        "Returns a detached interactive Figure. `kwargs` are passed to `iplot_rgb_lines` or `iplot_dos_lines` based on current figure. `kwargs` should exclude whatever inside `self._input` and `path_evr`"
        kwargs = {k:v for k,v in kwargs.items() if k not in self._input.keys() or k!='path_evr'}
        if self._dds['band_dos'].value == 'Bands':
            return ip.iplot_rgb_lines(path_evr=self._data,**self._input,**kwargs)
        else:
            return ip.iplot_dos_lines(path_evr=self._data,**self._input,**kwargs)

    def splot(self,**kwargs):
        "Returns matplotlib Axes.`kwargs` are passed to `splot_rgb_lines` or `splot_dos_lines` based on current figure. `kwargs` should exclude whatever inside `self._input` and `path_evr`"
        kwargs = {k:v for k,v in kwargs.items() if k not in self._input.keys() or k!='path_evr'}
        if self._dds['band_dos'].value == 'Bands':
            return sp.splot_rgb_lines(path_evr=self._data,**self._input,**kwargs)
        else:
            return sp.splot_dos_lines(path_evr=self._data,**self._input,**kwargs)

# Cell
class KPathApp:
    """View and trace path on BZ.
    - **Usage**
        > ka = KPathApp()
        > ka.show() #Display app
        > ka.splot() #get matplotlib figure
    """
    _output = ipw.Output().add_class('output')
    def __init__(self,path='POSCAR'):
        self.path = path
        self._files_gui = FilesWidget(glob='POSCAR')
        self._files_dd = self._files_gui.dropdown
        self._files_dd.layout.width = '50%'
        self._main_class = 'custom-'+''.join(np.random.randint(9,size=(21,)).astype(str)) #Random class
        self._tab = ipw.Tab(children=[self._files_gui,Box([]),self.__class__._output]).add_class(self._main_class)
        self._tab.add_class('marginless').add_class('borderless')
        self._tab.layout = Layout(width='100%',min_width='600px',height='450px',min_height='450px')
        try:
            for i,title in enumerate(['Home','Main','STDERR']):
                self._tab.set_title(i,title)
        except:
            self._tab.titles = ['Home','Main','STDERR']
        self.app = self._tab
        self._fig = go.FigureWidget()
        self._fig.layout.template = 'plotly_white' #Forces to avoid colored patch in background
        self.bz = None
        self.kcsn = [] #KPOINTS, COORDS,SYMBOLS, N_per_interval and box symbol in dictionary per item
        self._buttons = {'delete':Button(description='Delete Selection'),
                        'add':Button(description='Add Point'),
                        'fig_up': Button(description='Update Figure'),
                        'theme': Button(description='Dark Theme')}
        self.sm = SelectMultiple(layout=Layout(width='100%'))
        self._texts = {'label':Text(description='Label, N',indent=False),
                      'kxyz':Text(description='kx, ky, kz',indent=False)}
        self.theme_html = ipw.HTML(css_style(light_colors,_class=self._main_class))

        self._buttons['delete'].on_click(self.__delete)
        self._buttons['add'].on_click(self.__add)
        self._buttons['theme'].on_click(self.__toggle_theme)
        self._buttons['fig_up'].on_click(self.__update_fig)
        self._texts['label'].on_submit(self.__label)
        self._texts['kxyz'].on_submit(self.__manual_k)

        self.__update_fig()
        self.__build()

    @property
    def fig(self):
        return self._fig

    @_output.capture(clear_output=True,wait=True)
    def __toggle_theme(self,change):
        _style = '''<style>.widget-select-multiple>select {{
            font-family: "Cascadia Code","Ubuntu Mono","SimSun-ExtB","Courier New";
            background:{next_bg};border-radius:0;color:{accent};border:none;
            height:auto;min-height:160px;padding:5px;margin:0px;overflow:auto;}}
        .widget-select-multiple>select>option:hover,
        .widget-select-multiple>select>option:focus{{background:{hover_bg};}}</style>'''
        if self._buttons['theme'].description == 'Dark Theme':
            self.theme_html.value = css_style(dark_colors,_class = self._main_class) + _style.format(**dark_colors)
            self._fig.layout.template = 'plotly_dark'
            self._fig.layout.paper_bgcolor = dark_colors['main_bg'] #important
            self._buttons['theme'].description = 'Light Theme'
        else:
            self.theme_html.value = css_style(light_colors,_class=self._main_class) + _style.format(**light_colors)
            self._fig.layout.template = 'plotly_white'
            self._fig.layout.paper_bgcolor = light_colors['main_bg']
            self._buttons['theme'].description = 'Dark Theme'

    @_output.capture(clear_output=True,wait=True)
    def __manual_k(self,change):
        for i in self.sm.value:
            self.kcsn[i]['k'] = [float(v) for v in self._texts['kxyz'].value.split(',') if v != ''][:3]

        self._texts['kxyz'].value = '' # clean it
        self.__update_label()
        self.__update_selection() #Change on graph too

    def __label_at(self,i):
        self.kcsn[0]['b'], self.kcsn[-1]['b'] = '┌', '└'  #Avoid clashes
        _ln_ = f"─ {self.kcsn[i]['n']}" if self.kcsn[i]['n'] and i < (len(self.sm.options) - 1) else ""
        if self.kcsn[i]['k']:
            return "{0} {1} {2:>8.4f}{3:>8.4f}{4:>8.4f} {5}".format(self.kcsn[i]['b'],self.kcsn[i]['s'],*self.kcsn[i]['k'],_ln_)
        return f"{self.kcsn[i]['b']} {self.kcsn[i]['s']} {_ln_}"

    def __update_label(self):
        opt = list(self.sm.options)
        vs = self.sm.value # get before it goes away
        for i in vs:
            opt[i] = (self.__label_at(i),i)

        self.sm.options = tuple(opt)

    @_output.capture(clear_output=True,wait=True)
    def __build(self):
        for k,b in self._buttons.items():
            b.layout.width = 'max-content'
        for k,t in self._texts.items():
            t.layout.width='85%'
        top_row = HBox([self._files_dd,self._buttons['fig_up']]).add_class('borderless')
        _buttons1 = HBox([self._buttons[b] for b in ['add','delete']]).add_class('borderless')
        _buttons2 = HBox([self._buttons[b] for b in ['theme']]).add_class('borderless')
        self._tab.children = [self._tab.children[0],
                            HBox([
                                  VBox([self.theme_html,
                                        VBox([top_row,_buttons1,_buttons2],
                                        layout = Layout(min_height='140px')),
                                        Box([self.sm]).add_class('marginless').add_class('borderless'),
                                        *self._texts.values()],
                                  layout=Layout(min_width='320px')).add_class('borderless'),
                                  Box([self._fig]).add_class('borderless')],
                            layout=Layout(height='400px',width='auto')).add_class('borderless'),
                            self._tab.children[-1]]

    def show(self):
        return display(self._tab)

    def _ipython_display_(self):
        self.show()

    @_output.capture(clear_output=True,wait=True)
    def __delete(self,change):
        v = self.sm.value
        for i, kp in enumerate(self.kcsn):
            self.kcsn[i]['b'] = '├' #Break Path Retrieve first
        self.kcsn = [k for i,k in enumerate(self.kcsn) if i not in v]
        self.sm.options = [(self.__label_at(i),i) for i,op in enumerate(self.kcsn)]

    @_output.capture(clear_output=True,wait=True)
    def __add(self,change):
        if self.kcsn:
            self.kcsn.append({'k':[],'c':[],'s':'','n':'', 'b': '└'})
        else:
            self.kcsn.append({'k':[],'c':[],'s':'','n':'', 'b': '┌'})
        for i, kp in enumerate(self.kcsn[1:-1]):
            self.kcsn[i+1]['b'] = '├'

        self.sm.options = [*self.sm.options,('You just added me',len(self.sm.options))]
        self.sm.value = (len(self.sm.options) - 1,) # make available


    @_output.capture(clear_output=True,wait=True)
    def get_coords_labels(self):
        "`coords` are calculated for current `bz` even if `kpoints` were from other one. Useful in case of same kind of Zones with just basis changed."
        if self.bz:
            for i, kp in enumerate(self.kcsn):
                self.kcsn[i]['c'] = sio.to_R3(self.bz.basis,kp['k']).tolist() if kp['k'] else []

        coords = [kp['c'] for kp in self.kcsn]
        labels = [kp['s'] for kp in self.kcsn]
        numbers = [kp['n'] for kp in self.kcsn]
        j = 0
        for i,n in enumerate(numbers, start = 1):
            if isinstance(n, int) and n == 0:
                labels.insert(i+j,'NaN')
                coords.insert(i+j,[np.nan,np.nan,np.nan])
                j += 1

        coords = np.array([c for c in coords if c])
        labels = [l for l in labels if l]
        return coords,labels

    @_output.capture(clear_output=True,wait=True)
    def __update_selection(self):
        coords,labels = self.get_coords_labels()
        with self._fig.batch_animate():
            for trace in self._fig.data:
                if 'path' in trace.name and coords.any():
                    trace.x = coords[:,0]
                    trace.y = coords[:,1]
                    trace.z = coords[:,2]
                    trace.text = labels

    @_output.capture(clear_output=True,wait=True)
    def __click(self):
        def handle_click(trace, points, state):
            if points.ys != []:
                index = points.point_inds[0]
                kp = trace.hovertext[index]
                kp = [float(k) for k in kp.split('[')[1].split(']')[0].split()]
                cp = [trace.x[index],trace.y[index],trace.z[index]]
                for i in self.sm.value:
                    self.kcsn[i]['k'] = kp
                    self.kcsn[i]['c'] = cp

                self.__update_label()
                self.__update_selection()

        for trace in self._fig.data:
            if 'HSK' in trace.name:
                trace.on_click(handle_click)

    @_output.capture(clear_output=True,wait=True)
    def __update_fig(self,change=None):
        if self._files_dd.value:
            self.path = self._files_dd.value # update path may be needed somehere
            self.bz = sio.get_bz(self.path)
            fig = sio.iplot_bz(self.bz, fill = False,color = 'red',background = 'rgba(1,1,1,0)')
            ip.iplot2widget(fig, self._fig) # return is not needed, self._fig is updated
            self._fig.layout.scene.aspectmode = 'data' #very important
            
            with self._fig.batch_animate():
                self._fig.add_trace(go.Scatter3d(x = [],y = [],z = [],
                    mode='lines+text',name='path',text=[], hoverinfo='none', # dont let it block other points
                    textfont_size=18))
                self.__update_selection() #Show previous path on current fig.

            self.__click()


    @_output.capture(clear_output=True,wait=True)
    def __label(self,change):
        for i in self.sm.value:
            inbox = self._texts['label'].value.split(',')
            self.kcsn[i]['s'] = 'Γ' if 'am' in inbox[0] else inbox[0] #fix gamma
            try: self.kcsn[i]['n'] = int(inbox[1])
            except: pass
            self._texts['label'].value = '' # Clear it
        self.__update_label()
        self.__update_selection()


    def get_selected_kpoints(self):
        return tuple((*kp['k'],kp['s'],kp['n']) if isinstance(kp['n'],(int, np.integer)) else (*kp['k'],kp['s']) for kp in self.kcsn) #k,s,n
        
    def get_kpath(self,n = 5,weight = None,ibzkpt = None,outfile = None):
        "See Docs of ipyvasp.POSCAR.get_kpath for details."
        kws = {k:v for k,v in locals().items() if k != 'self'}
        from ipyvasp import POSCAR
        return POSCAR(self.path).get_kpath(self.get_selected_kpoints(),**kws)

    def splot(self,plane = None, text_kws = {}, plot_kws ={}, **kwargs):
        """Same as `pp.splot_bz` except it also plots path on BZ.

        - text_kws: dict of keyword arguments for `plt.text`
        - plot_kws: dict of keyword arguments for `plt.plot`
        `kwargs` are passed to `pp.splot_bz`"""
        ax = sio.splot_bz(self.bz,plane = plane, **kwargs)
        coords,labels = self.get_coords_labels()
        if plane is not None and plane in 'xyzxzyx':
            ind = 'xyzxzyx'.index(plane)
            arr = [0,1,2,0,2,1,0]
            ix,iy = arr[ind],arr[ind+1]
            coords = coords[:,[ix,iy]]
        if coords.any(): #To avoid errors if not coords
            ax.plot(*coords.T,'-o',**plot_kws)
            _ = [ax.text(*vs,lab, **text_kws) for vs,lab in zip(coords,labels) if lab!='NaN']
        return ax
    def iplot(self):
        "Returns disconnected current plotly figure"
        return go.Figure(data=self._fig.data, layout=self._fig.layout)