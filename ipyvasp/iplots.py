# AUTOGENERATED! DO NOT EDIT! File to edit: InteractivePlots.ipynb (unless otherwise specified).

__all__ = ['iplot2html', 'iplot_rgb_lines', 'iplot_dos_lines']

# Cell
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt

import plotly.graph_objects as go

# Inside packages import to work both with package and jupyter notebook.
try:
    from ipyvasp import parser as vp
    from ipyvasp import splots as sp
    from ipyvasp import utils as gu
except:
    import ipyvasp.parser as vp
    import ipyvasp.splots as sp
    import ipyvasp.utils as gu
    

def _format_rgb_data(K, E, pros, labels, interp, occs, kpoints, maxwidth = 10):
    "Transform data to 1D for rgb lines to plot effectently. Output is a dictionary."
    data = sp._fix_data(K, E, pros, labels, interp, rgb = True, occs = occs, kpoints = kpoints)
    # Note that data['pros'] is normalized to 0-1
    rgb = np.zeros((*np.shape(data['evals']),3)) # Initialize rgb array, because there could be less than three channels
    if data['pros'].shape[2] == 3:
        rgb = data['pros']
    elif data['pros'].shape[2] == 2:
        rgb[:,:,:2] = data['pros'] # Normalized overall color data
        labels = [*labels, '']
    elif data['pros'].shape[2] == 1:
        rgb[:,:,:1] = data['pros'] # Normalized overall color data
        labels = [*labels, '','']
    
    # Since normalized data is Y = (X - X_min)/(X_max - X_min), so X = Y*(X_max - X_min) + X_min is the actual data.
    low, high = data['ptp']
    data['norms'] = np.round(rgb*(high - low) + low, 3) # Read actual data back from normalized data.
    if data['pros'].shape[2] == 2:
        data['norms'][:,:,2] = np.nan # Avoid wrong info here
    elif data['pros'].shape[2] == 1:
        data['pros'][:,:,1:] = np.nan
    
    lws = np.sum(rgb,axis = 2) # Sum of all colors
    lws = maxwidth*lws/(float(np.max(lws)) or 1) # Normalize to maxwidth
    data['widths'] = 0.0001 + lws #should be before scale colors, almost zero size of a data point with no contribution.
    

    # Now scale colors to 1 at each point.
    cl_max = np.max(data['pros'],axis=2)
    cl_max[cl_max==0.0] = 1 # avoid divide by zero. Contributions are 4 digits only.
    data['pros'] = (rgb/cl_max[:,:,np.newaxis]*255).astype(int) # Normalized per point and set rgb data back to data.
    
    # Now process data to make single data for faster plotting.
    txt = 'Projection: [{}]</br>Value:'.format(', '.join(labels))
    K, E, C, S, PT, OT, KT, ET = [], [], [], [], [], [], [], []
    for i in range(np.shape(data['evals'])[1]):
        K  = [*K, *data['kpath'], np.nan]
        E  = [*E, *data['evals'][:,i], np.nan]
        C  = [*C, *[f'rgb({r},{g},{b})' for (r,g,b) in data['pros'][:,i,:]], 'rgb(0,0,0)']
        S  = [*S, *data['widths'][:,i], data['widths'][-1,i]]
        PT = [*PT, *[f'{txt} [{s}, {p}, {d}]' for (s,p,d) in data['norms'][:,i]], ""]
        OT = [*OT, *[f'Occ: {t:>7.4f}' for t in data['occs'][:,i]], ""]
        KT = [*KT, *[f'K<sub>{j+1}</sub>: {x:>7.3f}{y:>7.3f}{z:>7.3f}' for j, (x,y,z) in enumerate(data['kpoints'])], ""]
        ET = [*ET, *["{}".format(i+1) for _ in data['kpath']],""] # Add subscripts to labels.
    
    if np.shape(data['evals'])[1] == 1: # If only one band, then remove last nan.
        K, E, C, S, PT, OT, KT, ET = K[:-1], E[:-1], C[:-1], S[:-1], PT[:-1], OT[:-1], KT[:-1], ET[:-1]
    
    T = [f"</br>{p} </br></br>Band: {e}  {o}</br>{k}" for (p,e,o,k) in zip(PT,ET, OT,KT)]
    return {'K':K, 'E':E, 'C':C, 'S':S, 'T':T, 'labels': labels} # K, energy, marker color, marker size, text, labels that get changed


# Cell
def iplot2html(fig,filename = None, out_string = False, modebar = True):
    """
    - Writes plotly's figure as HTML file or display in IPython which is accessible when online. It is different than plotly's `fig.to_html` as it is minimal in memory. If you need to have offline working file, just use `fig.write_html('file.html')` which will be larger in size.
    Args:
        - fig      : A plotly's figure object.
        - filename : Name of file to save fig. Defualt is None and show plot in Colab/Online or return hrml string.
        - out_string: If True, returns HTML string, if False displays graph if possible.
    """
    import uuid # Unique div-id required,otherwise jupyterlab renders at one place only and overwite it.
    div_id = "graph-{}".format(uuid.uuid1())
    fig_json = fig.to_json()
    # a simple HTML template
    if filename:
        _filename = gu.prevent_overwrite(filename)
        template = """<html>
        <head>
        <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
        </head>
        <body>
            <div id='{}'></div>
            <script>
                var fig_data = {}
                Plotly.react('{}', fig_data.data, fig_data.layout);
            </script>
        </body>
        </html>"""

        # write the JSON to the HTML template
        with open(_filename, 'w') as f:
            f.write(template.format(div_id,fig_json,div_id))

    else:
        if modebar==True: #Only for docs issue
            config = "{displayModeBar: true,scrollZoom: true}"
        else:
            config = "{displayModeBar: false,scrollZoom: true}"
        template = """<div>
        <script src='https://cdn.plot.ly/plotly-latest.min.js'></script>
            <div id='{}'><!-- Plotly chart DIV --></div>
            <script>
                var data = {};
                var config = {};
                Plotly.newPlot('{}', data.data,data.layout,config);
            </script>
        </div>""".format(div_id,fig_json,config,div_id)
        if out_string is True:
            return template
        else:
            from IPython.display import HTML
            return HTML(template)
        
def iplot_rgb_lines(K, E, pros, labels, occs, kpoints,
    fig        = None,
    elim       = None,
    kticks     = None, 
    interp     = None, 
    maxwidth   = 10,   
    mode       = 'markers + lines',
    title      = None,
    **kwargs        
    ):
    """
    Interactive plot of band structure with rgb data points using plotly.
    
    Parameters
    ----------
    K : array-like, shape (nk,)
    E : array-like, shape (nk,nb)
    pros : array-like, shape (m,nk,nb), m is the number of projections
    labels : list of str, length m
    occs : array-like, shape (nk,nb)
    kpoints : array-like, shape (nk,3)
    fig : plotly.graph_objects.Figure, if not provided, a new figure will be created
    elim : tuple, (emin,emax), energy range to plot
    kticks : [(int, str),...] for indices of high symmetry k-points. To join a broken path, use '<=' before symbol, e.g.  [(0, 'G'),(40, '<=K|M'), ...] will join 40 back to 39. You can also use shortcut like zip([0,10,20],'GMK').
    interp : int or list/tuple of (n,k) for interpolation. If int, n is number of points to interpolate. If list/tuple, n is number of points and k is the order of spline.
    maxwidth : float, maximum linewidth, 10 by default
    mode : str, plotly mode, 'markers + lines' by default, see modes in `plotly.graph_objects.Scatter`.
    title : str, title of the figure, labels are added to the end of the title.
    
    kwargs are passed to `plotly.graph_objects.Scatter`.
    
    Returns
    -------
    fig : plotly.graph_objects.Figure that can be displayed in Jupyter notebook or saved as html using `iplot2html`.
    """
    K, E, xticks, xticklabels = sp._validate_data(K,E,elim,kticks,interp)
    data = _format_rgb_data(K, E, pros, labels, interp, occs, kpoints,maxwidth = maxwidth)
    K, E, C, S, T, labels = data['K'], data['E'], data['C'], data['S'], data['T'], data['labels']
    
    if fig is None:
        fig = go.Figure()
        
    kwargs.pop('marker_color',None) # Provided by C
    kwargs.pop('marker_size',None) # Provided by S
    kwargs.update({'hovertext': T, 'marker': {'line_color': 'rgba(0,0,0,0)', **kwargs.get('marker',{}), 'color': C, 'size': S}}) # marker edge should be free
    
    fig.add_trace(go.Scatter(x = K, y = E, mode = mode, **kwargs))
    
    fig.update_layout(title = (title or '') + '[' + ', '.join(labels) + ']',
            margin=go.layout.Margin(l=60,r=50,b=40,t=75,pad=0),
            yaxis = go.layout.YAxis(title_text = 'Energy (eV)',range = elim or [min(E), max(E)]),
            xaxis = go.layout.XAxis(ticktext = xticklabels, tickvals = xticks,tickmode = "array",range = [min(K), max(K)]),
            font = dict(family="stix, serif",size=14)
    )

    update_args = dict(linewidth = 0.1,linecolor = 'rgba(222,222,222,0.1)', mirror = True)
    fig.update_xaxes(showgrid = True,zeroline = False,showline = True,**update_args)
    fig.update_yaxes(showgrid = False,zeroline = True,showline = True,**update_args)
    return fig


# Cell
def iplot_dos_lines(
    path_evr      = None,
    atoms      = [[0,],],
    orbs          = [[0],],
    labels        = ['s',],
    elim          = [],
    colormap      = 'gist_rainbow',
    tdos_color    = (0.5,0.95,0),
    linewidth     = 2,
    fill_area     = True,
    vertical      = False,
    Fermi       = None,
    figsize       = None,
    spin          = 'both',
    interp        = None,
    title         = None,
    atoms_orbs_dict    = {}
    ):
        """
        - Returns plotly's figure. If given,atoms,orbs colors, and labels must have same length. If not given, zeroth ions is plotted with s-orbital.
        Args:)
            - path_evr   : Path/to/vasprun.xml or output of `export_vasprun`. Auto picks in CWD.
            - atoms   : List [[0,],] of ions indices, by defualt plot first ion's projections.
            - orbs       : List [[0,],] lists of indices of orbitals, could be empty.
            - labels     : List [str,] of orbitals labels. len(labels) == len(orbs) must hold.
            - elim       : [min,max] of energy range.
            - Fermi    : If not given, automatically picked from `export_vasprun`.
            - colormap   : Matplotlib's standard color maps. Default is 'gist_ranibow'. Use 'RGB' if want to compare with `iplot_rgb_lines` with 3 projection inputs (len(orbs)==3).
            - fill_area  : Default is True and plots filled area for dos. If False, plots lines only.
            - vertical   : False, If True, plots along y-axis.
            - interp : int or list/tuple of (n,k) for interpolation. If int, n is number of points to interpolate. If list/tuple, n is number of points and k is the order of spline.
            - figsize    : Tuple(width,height) in pixels, e.g. (700,400).
            - atoms_orbs_dict : Dictionary with keys as label and values as list of length 2. If given, used in place of atoms, orbs and labels arguments.
                        Example: {'s':([0,1],[0]),'p':([0,1],[1,2,3]),'d':([0,1],[4,5,6,7,8])} will pick up s,p,d orbitals of first two ions of system.
        - **Returns**
            - fig        : Plotly's figure object.
        """
        if atoms_orbs_dict:
            atoms,orbs,labels = sp._format_input(atoms_orbs_dict,rgb=False) # prefer atoms_orbs_dict over atoms,orbs,labels
            # These are validated inisde _collect_dos, no need here
        en,tdos,pdos,vr=None,None,None,None # Place holders for defining
        cl_dos = sp._collect_dos(path_evr=path_evr,elim=elim,
                            atoms=atoms, orbs=orbs,labels=labels,
                            Fermi=Fermi, spin='both',interp=interp)
        try:
            en,tdos,pdos,labels,vr = cl_dos
        except:
            raise ValueError("Try with large energy range.")

        labels=[label.replace('$','').replace('^↑','<sup>↑</sup>').replace('^↓','<sup>↓</sup>') for label in labels]
        # Make additional colors for spin down. Inverted colors are better.
        if(elim):
            ylim=[min(elim),max(elim)]
        else:
            ylim=[-10,10]
        # Fix atoms and colors length
        if colormap in plt.colormaps():
            from matplotlib.pyplot import cm
            if len(tdos) == 2:
                c_map   = cm.get_cmap(colormap)
                c_vals  = np.linspace(0,1,2*len(orbs))
                colors  = c_map(c_vals)
            else:
                c_map   = cm.get_cmap(colormap)
                c_vals  = np.linspace(0,1,len(orbs))
                colors  = c_map(c_vals)
            # Fix for RGB comparison
            if len(tdos) == 2 and 'both' in spin and len(orbs)==3:
                colors[[-1,-2]]= colors[[-2,-1]] #Flip last two colors only
        else:
            raise ValueError("`colormap` expects one of the follwoing:\n{}".format(plt.colormaps()))
        # Total DOS colors
        t_color=mpl.colors.to_rgb(tdos_color)
        it_color=gu.transform_color(t_color,c = -1) #inverts for c = -1
        #========Title Name========
        SYSTEM=vr.sys_info.SYSTEM
        if(title==None):
            title="{}".format(SYSTEM)

        fig = go.Figure()
        fig.update_layout(title=title,margin=go.layout.Margin(l=60,r=50,b=40,t=75,pad=0),\
                          font=dict(family="stix, serif",size=14))
        if(figsize!=None):
            fig.update_layout(width=figsize[0],height=figsize[1],autosize=False)
        if(vertical==False):
            if(fill_area==False):
                fill=None
            if(fill_area==True):
                fill='tozeroy'
            args_dic=dict(mode='lines',linewidth=linewidth,fill=fill)
            fig.update_xaxes(range=ylim,title='Energy (eV)')
            if(len(tdos)==2):   # Spin polarized.
                fig.add_scatter(x=en,y=tdos[0],line_color='rgb({},{},{})'.format(*[int(255*i) for i in t_color]),\
                                 name='TDOS<sup>↑</sup>',**args_dic)
                fig.add_scatter(x=en,y=tdos[1],line_color='rgb({},{},{})'.format(*[int(255*i) for i in it_color]),\
                                 name='TDOS<sup>↓</sup>',**args_dic)
            else:   # unpolarized.
                fig.add_trace(go.Scatter(x=en,y=tdos,line_color='rgb({},{},{})'.format(*[int(255*i) for i in t_color]),\
                              name='TDOS',**args_dic))
            for p,l,c in zip(pdos,labels,colors):
                fig.add_trace(go.Scatter(x=en,y=p,line_color='rgb({},{},{})'.format(*[int(255*i) for i in c]),\
                               name=l,**args_dic))
        if(vertical==True):
            if(fill_area==False):
                fill=None
            if(fill_area==True):
                fill='tozerox'
            args_dic=dict(mode='lines',linewidth=linewidth,fill=fill)
            fig.update_yaxes(range=ylim,title='Energy (eV)')
            if(len(tdos)==2):   # Spin polarized.
                fig.add_scatter(y=en,x=tdos[0],line_color='rgb({},{},{})'.format(*[int(255*i) for i in t_color]),\
                                name='TDOS<sup>↑</sup>',**args_dic)
                fig.add_scatter(y=en,x=tdos[1],line_color='rgb({},{},{})'.format(*[int(255*i) for i in it_color]),\
                                name='TDOS<sup>↓</sup>',**args_dic)
            else:   # unpolarized.
                fig.add_trace(go.Scatter(y=en,x=tdos,line_color='rgb({},{},{})'.format(*[int(255*i) for i in t_color]),\
                                name='TDOS',**args_dic))
            for p,l,c in zip(pdos,labels,colors):
                fig.add_trace(go.Scatter(y=en,x=p,line_color='rgb({},{},{})'.format(*[int(255*i) for i in c]),\
                                name=l,**args_dic))
        fig.update_xaxes(showgrid=True, zeroline=True,showline=True, linewidth=0.1, linecolor='rgba(222,222,222,0.1)', mirror=True)
        fig.update_yaxes(showgrid=True, zeroline=True,showline=True, linewidth=0.1, linecolor='rgba(222,222,222,0.1)', mirror=True)
        return fig

